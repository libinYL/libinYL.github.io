<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python安装目录疑难]]></title>
    <url>%2F2018%2F06%2F29%2Fnote-python-path%2F</url>
    <content type="text"><![CDATA[使用 pip install 安装时： 如果有--user参数时，则安装到:\Users\libin\AppData\Roaming\Python\Python36\site-packages 如果没有--user参数，则安装到C:\Users\libin\AppData\Local\Programs\Python\Python36\Lib\site-packages下。 后者没有在环境变量下，且实际上并不看重用户的区分，故没有必要用--user参数。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180628]]></title>
    <url>%2F2018%2F06%2F29%2Fdiary20180628%2F</url>
    <content type="text"><![CDATA[00:20:31 7月2号回家，3号到家。这几天每天晚睡晚起。 03:18:23 接触了jupyter，numpy，pandas，才发现python实在太强大了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180627]]></title>
    <url>%2F2018%2F06%2F27%2Fdiary20180627%2F</url>
    <content type="text"><![CDATA[16:45:15 即将去梅溪湖那边看电影，吃好吃。 00:31:29 晚上与胡去了梅溪湖那边吃了烤鱼，然后看《阿飞正传》——竟然是国语！断然离开，立刻买了潇湘的票。结果没太看懂。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180626]]></title>
    <url>%2F2018%2F06%2F27%2Fdiary20180626%2F</url>
    <content type="text"><![CDATA[01:00:22 给学弟装了程序，发了我50块的红包，大方的学弟啊。给我政继续写程序。突然对CUDA感兴趣了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180625]]></title>
    <url>%2F2018%2F06%2F25%2Fdiary20180625%2F</url>
    <content type="text"><![CDATA[15:00:00 去遥远的湘雅附近买了弹性绷带。 21:08:23 帮政写了个python的程序，现学python的感觉真爽 12345678910111213141516171819202122232425262728293031#train.csvimport csv,geohash l = list()file2 = open("target.csv","w",newline='')writer = csv.writer(file2)file1 = open("train.csv","rt")reader=csv.reader(file1)next(reader)writer.writerow(['orderid','userid','bikeid','biketype','startdate','starttime','geohashed_start_loc_long','geohashed_start_loc_lat','geohashed_end_loc_long','geohashed_end_loc_lat'])for line in reader: for index,data in enumerate(line): if(index&lt;=3): l.append(data) if(index==4): l.append(data.split()[0]) l.append(data.split()[1]) if(index==5): l.append(geohash.decode(data)[0]) l.append(geohash.decode(data)[1]) if(index==6): l.append(geohash.decode(data)[0]) l.append(geohash.decode(data)[1]) writer.writerow(l) l=[]file1.close()file2.close() 数据内容样式： orderid userid bikeid biketype starttime geohashed_start_loc geohashed_end_loc 1893973 451147 210617 2 2017/5/14 22:16 wx4snhx wx4snhj 4657992 1061133 465394 1 2017/5/14 22:16 wx4dr59 wx4dquz 2965085 549189 310572 1 2017/5/14 22:16 wx4fgur wx4fu5n 4548579 489720 456688 1 2017/5/14 22:16 wx4d5r5 wx4d5r4 3936364 467449 403224 1 2017/5/14 22:16 wx4g27p wx4g266 5163705 917620 509044 1 2017/5/14 22:16 wx4gd2e wx4g6pw 转化结果样式： orderid userid bikeid biketype startdate starttime geohashed_start_loc_long geohashed_start_loc_lat geohashed_end_loc_long geohashed_end_loc_lat 1893973 451147 210617 2 2017/5/14 22:16 40.1 116.29 40.1 116.29 4657992 1061133 465394 1 2017/5/14 22:16 39.79 116.33 39.8 116.32 2965085 549189 310572 1 2017/5/14 22:16 39.88 116.54 39.88 116.55 4548579 489720 456688 1 2017/5/14 22:16 39.77 116.16 39.77 116.16 3936364 467449 403224 1 2017/5/14 22:16 39.96 116.39 39.96 116.38 5163705 917620 509044 1 2017/5/14 22:16 39.99 116.47 39.99 116.46]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180624]]></title>
    <url>%2F2018%2F06%2F24%2Fdiary20180624%2F</url>
    <content type="text"><![CDATA[18:38:57 炎热的一天，凯李没有空位，只能回家。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180623]]></title>
    <url>%2F2018%2F06%2F24%2Fdiary20180623%2F</url>
    <content type="text"><![CDATA[02:13:26 下午6点多去五一广场绕了一圈，除了看到一个超大的星巴克，没有什么新的发现。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180622]]></title>
    <url>%2F2018%2F06%2F22%2Fdiary20180622%2F</url>
    <content type="text"><![CDATA[12:09:55 上午毕业典礼。 鸟巢全景]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180621]]></title>
    <url>%2F2018%2F06%2F21%2Fdiary20180621%2F</url>
    <content type="text"><![CDATA[16:12:53 去河东买药，竟然无意中去了咖啡之翼大厦。好矮的大厦。。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[note-maven-basic]]></title>
    <url>%2F2018%2F06%2F20%2Fnote-maven-basic%2F</url>
    <content type="text"><![CDATA[总览 maven有自己的生命周期，从开始执行到结束，依次经过。 maven的每个插件都有一个目标。 maven把某个目标绑定在某个生命周期阶段 这样一来，随着生命周期的执行，不同目标也随之执行。 生命周期maven有三种周期： 清洁（clean） 默认（default） 站点（site） “清洁”的声明周期 具体周期 作用 预清洁（pre-clean） 执行实际项目清理之前所需的流程 清洁（clean） 删除以前构建生成的所有文件 后清洁（post-clean） 执行完成项目清理所需的流程 “默认”的生命周期 具体周期 作用 验证（validate） 验证项目是正确的，所有必要的信息可用。 初始化（initialize） 初始化构建状态，例如设置属性或创建目录。 产生来源（generate-sources） 生成包含在编译中的任何源代码。 流程源（process-sources） 处理源代码，例如过滤任何值。 生成资源（generate-resources） 生成包含在包中的资源。 流程资源（process-resources） 将资源复制并处理到目标目录中，准备打包。 编译（compile） 编译项目的源代码。 工艺类（process-classes） 从编译后处理生成的文件，例如对Java类进行字节码增强。 生成测试来源（generate-test-sources） 生成包含在编译中的任何测试源代码。 流程测试来源（process-test-sources） 处理测试源代码，例如过滤任何值。 生成测试资源（generate-test-resources） 创建测试资源。 流程测试资源（process-test-resources） 将资源复制并处理到测试目标目录中。 测试编译（test-compile） 将测试源代码编译到测试目标目录中 流程检验类（process-test-classes） 从测试编译中处理生成的文件，例如对Java类进行字节码增强。对于Maven 2.0.5及以上版本。 测试（test） 使用合适的单元测试框架运行测试。这些测试不应该要求代码被打包或部署。 制备包（prepare-package） 在实际包装之前，执行必要的准备包装的操作。这通常会导致打包的处理版本的包。（Maven 2.1及以上） 打包（package） 采取编译的代码，并以其可分发的格式（如JAR）进行打包。 预集成测试（pre-integration-test） 在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境等。 集成测试（integration-test） 如果需要，可以将该包过程并部署到可以运行集成测试的环境中。 整合后的测试（post-integration-test） 执行集成测试后执行所需的操作。这可能包括清理环境。 校验（verify） 运行任何检查以验证包装是否有效并符合质量标准。 安装（install） 将软件包安装到本地存储库中，以作为本地其他项目的依赖关系。 部署（deploy） 在集成或发布环境中完成，将最终软件包复制到远程存储库，以与其他开发人员和项目共享。 “站点”生命周期 具体周期 | 作用预网站（pre-site） | 在实际的项目现场生成之前执行所需的进程网站（site） | 生成项目的站点文档后网站（post-site） | 执行完成站点生成所需的进程，并准备站点部署网站部署（site-deploy） | 将生成的站点文档部署到指定的Web服务器 样例在执行mvn install时，以下插件对应的目标执行：]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180620]]></title>
    <url>%2F2018%2F06%2F20%2Fdiary20180620%2F</url>
    <content type="text"><![CDATA[16:21:40 来到久违的凯李，感觉非常好。上午把学士服还了。 18:49:19 看了《maven权威指南》，这才是技术书！看的真tm爽！ 20:34:49 韩佳政说要请我，已截图 20:34:49 离开凯李。久违的充实。。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180619]]></title>
    <url>%2F2018%2F06%2F19%2Fdiary20180619%2F</url>
    <content type="text"><![CDATA[13:12:08 上午打印了论文任务书，给了陈靖。去图书馆把书还了。 19:30:28 尝试开发intellij的插件，发现git clone真是慢。进行一系列修补。胀起来是真疼，物理上自律，真是牛逼。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[intelliJ配置实践]]></title>
    <url>%2F2018%2F06%2F18%2Fnote-intellij-config%2F</url>
    <content type="text"><![CDATA[设置 原生IntelliJ主题，不要黑色 字体选择Fira Code，行距为1.2 插件 GsonFormat Translation]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>intelliJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180618]]></title>
    <url>%2F2018%2F06%2F18%2Fdiary20180618%2F</url>
    <content type="text"><![CDATA[17:12:52 到医院换了药，情况良好。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180617]]></title>
    <url>%2F2018%2F06%2F17%2Fdiary20180617%2F</url>
    <content type="text"><![CDATA[23:40:34 折腾了两天，装了ubuntu又换了回来。实在是太折腾了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180615]]></title>
    <url>%2F2018%2F06%2F15%2Fdiary20180615%2F</url>
    <content type="text"><![CDATA[13:44:25 刷了一堆关于医学、医学生的东西，对医学从业者毕恭毕敬、肃然起敬。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180614]]></title>
    <url>%2F2018%2F06%2F14%2Fdiary20180614%2F</url>
    <content type="text"><![CDATA[21:37:27 手术完成，白天疼了两个小时，基本就没感觉了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180613]]></title>
    <url>%2F2018%2F06%2F13%2Fdiary20180613%2F</url>
    <content type="text"><![CDATA[07:26:48 好不容易打了次电话，竟然是以“醒了”为结局，真是浪费感情… 12:41:56 今天上午毕业典礼，拨流苏，合影。 中南图书馆 学位授予仪式 快到我啦 20:49:55 补一下前几天拍的照片。 湘江 南 湘江 北 湘江 黄昏 20:53:35 毕设即将结束系列。 胶装的论文 即将离我而去的资料袋 跟踪表]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springMVC学习笔记]]></title>
    <url>%2F2018%2F06%2F12%2Fnote-springmvc%2F</url>
    <content type="text"><![CDATA[依赖关系 总述 Controller一般负责准备一个将一个view和data映射为一个数据类型为Map的model并返回。也可以直接写入数据到返回流中。 一个view反应到代码层面就是一个字符串，对应着视图文件；一个model是一个Map，包含着许多键值对，key是某个变量，value是其对应的数据。 DispatcherServlet作为中央Servlet，DispatcherServlet负责分发，由具体的可配置的控件执行实际的工作。 初始化DispatcherServlet毕竟也是Servlet，也需要在web.xml中配置。在以下例子中，配置了一个DispatcherServlet,配置了其配置文件app-context.xml的路径，配置了DispatcherServlet接收请求的路径/app/*。 12345678910111213141516171819202122&lt;web-app&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 或者用注解的方式： 1234567891011121314151617public class MyWebApplicationInitializer implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext servletCxt) &#123; // Load Spring web application configuration AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext(); ac.register(AppConfig.class); ac.refresh(); // Create and register the DispatcherServlet DispatcherServlet servlet = new DispatcherServlet(ac); ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet); registration.setLoadOnStartup(1); registration.addMapping("/app/*"); &#125;&#125; Context 的层级关系 在Spring中，ApplicationContext是典型容器。在SpringMVC中，WebApplicationContext作为其拓展，成为web环境的Ioc容器。 WebApplicationContext作为DispatcherServlet的配置，与ServletContext和它所关联的Servlet关联。 特殊的Bean类型处理过程DispatcherServlet对请求的处理流程： 搜索WebApplicationContext，将其作为一个属性，与请求绑定，以便controller等组件可以使用。 地域解析器（locale resolver）被绑定在请求上，用于处理地域相关的逻辑，如渲染试图，数据准备等。这是可选的。 主题解析器（theme resolver）被绑定在请求上，以便view等组件可以获知使用哪个主题。这是可选的。 如果指定了多部件处理器（multipart file resolver），则请求被包装为MultipartHttpServletRequest，以便后续处理。 搜索一个合适的处理器（handler）。一旦找到，则与该处理器相关的执行链（execution chain）将被执行，用与准备model或者渲染。 如果返回了model，则渲染视图。如果没返回model，则不渲染视图。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180612]]></title>
    <url>%2F2018%2F06%2F12%2Fdiary20180612%2F</url>
    <content type="text"><![CDATA[19:45:11 今天去了湘雅附二。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring框架学习-Core]]></title>
    <url>%2F2018%2F06%2F11%2Fnote-spring-framework%2F</url>
    <content type="text"><![CDATA[IoC总览 org.springframework.beans和org.springframework.context是IOC容器的基础，都依赖于core包。 beans包内的BeanFacotry接口提供基本的配置对象的方法。context包内的ApplicationContext是其子接口之一，增加了实用的配置方法，是前者的超集。 org.springframework.context.ApplicationContext代表了IOC容器，负责实例化、配置、装配bean。它通过读取配置元数据来获取实例化等的方式。元数据可以通过xml，注解，或代码来表示。ApplicationContext的一些实现，如ClassPathXmlApplicationContext，FileSystemXmlApplicationContext等提供了方便的读取方法。 IOC容器读取元数据，结合POJOS，产生所需的系统。 Ioc container 容器元数据的配置方式 从Spring 2.5开始支持注解配置方法。 从Spring 3.0开始支持基于java的方式，即通过java类来表示配置。 IOC容器的实例化和使用 只需将配置文件的地址作为资源传给容器类。如： 1ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml"); 在配置beans.xml等资源文件时，形如“classpath:”的路径是不被推荐的。因为classpath虽然默认是指当前目录，但是也可以配置为其他目录。 可以通过容器的getBean方法来获取实例，但没有必要，因为这依赖于Spring的API。应该考虑注解等方式。 Beanbean的每个属性都映射为一个bean definition。 class Instantiating beans name Naming beans scope Bean scopes constructor arguments Dependency Injection properties Dependency Injection autowiring mode Autowiring collaborators lazy-initialization mode Lazy-initialized beans initialization method Initialization callbacks destruction method Destruction callbacks 每个bean可以有多个id，多余的id视为别名。 DI 依赖注入 依赖注入的Spring官方解释：依赖注入是由对象在构造（或从工厂方法返回）之后，仅仅通过构造方法参数、工厂方法参数等定义它们之间依赖关系的过程。容器创造这些bean之后，将对象们依赖的对象注入进去。这个过程从根本上来说是反转的，由bean自己通过构造方法（或Service Locator pattern）来控制依赖对象的实例化或者位置，故也称控制反转。 这样的好处是什么？在哪些方面解耦了？ 解耦依赖关系：由于容器帮对象提供了依赖关系，所以对象自己不再去寻找它所依赖的对象，不需要关心其依赖对象的位置或具体类。 方便测试：当依赖的对象是接口或者抽象类时，可以使用stub或mock来进行单元测试。 依赖注入的方式 基于构造方法注入 基于Setter方法注入 注入方式的比较？ 基于构造方法的注入有强制性。基于Setter的注入方法有可选性（可以通过@Required注解控制可选性）。 Spring团队主张用基于构造的方法。因为这能防止依赖对象是null。但是当参数过多时，应当考虑重构，将责任分开。 Setter注入方式需要时刻检查notnull。setter方法使该类的对象可以稍后重新配置或重新注入。因此，通过JMX mbean的管理是setter注入的一个不错的方式。 当第三方类没有提供任何setter方法，通过构造方法注入是唯一的选择。 bean的实例化时机？ 设置为单例模式即“预实例化”的bean在容易创建之后就被创建了。 其他情况下，随需实例化。 循环依赖是什么？怎样解决？ 如果（通过构造方法）配置A依赖B，B依赖A，则抛出异常。 解决方案：配置为setter注入。 自动装配 自动装配的几种模式？ no 不自动装配。 byName 通过属性name来装配。 byType 通过type来装配。 constructor 通过构造器来装配。 Bean 作用域 singlton prototype request session application websocket 单例模式作用域 Ioc容器只创建此对象的一个实例，将其存储在缓存中，每个对其依赖或引用都返回此缓存对象。 基于Java的容器设置方法核心是@Configuration和Bean注解。 @Bean与&lt;bean/&gt;类似，需要与@Configuration搭配使用，而免于用xml来配置。 AOP]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180611]]></title>
    <url>%2F2018%2F06%2F11%2Fdiary20180611%2F</url>
    <content type="text"><![CDATA[23:23:41 这两天复习Spring，内容真的多。下午自己去河东，顺便吃了顿佰烧。 23:44:06 最近的行程： 6月13日 院里照相 6月22日 毕业典礼 扫描所有证件 7月2日 回家 7月3日 到家 7月11日 到北京办理入住 7月12日 周四 体检 7月16日 周一 入职]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180610]]></title>
    <url>%2F2018%2F06%2F10%2Fdiary20180610%2F</url>
    <content type="text"><![CDATA[13:13:37 如果早起不干事，还不如多睡会。早早起来，只把毕设什么的打印了。没做什么好事。 00:19:08 今天时间过得挺慢的，看上面一行字都不像今天写的。下载了刺客信条，垃圾的显卡让我无法尽兴。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[thought-body]]></title>
    <url>%2F2018%2F06%2F09%2Fthought-body%2F</url>
    <content type="text"><![CDATA[column0 column1 2018060810 138.5 2018060823 140.2 2018060909 139.5 2018060913 139.1 2018060917 138.6 2018060923 140.3 2018061017 140.7 2018061020 139.9 2018061109 138.2 2018061123 140.6 2018061211 138.9]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180609]]></title>
    <url>%2F2018%2F06%2F09%2Fdiary20180609%2F</url>
    <content type="text"><![CDATA[9:00:06 最近闲暇时间听过，怎样分配时间呢。 13:06:07 些许健了身。哪怕十分钟，这一天都是赚的。 17:21:23 刷了几道简单的leetoode，感觉不错。 22:31:15 晚上与胡去了凯李咖啡。 我才意识到问题所在。我止不住的焦虑和好强，来自于高中的习惯。“不学习就是犯罪”，我竟早已被衡中洗脑，而且长久以来都没有意识到。这显然不是好事，但也未必是坏事。坏在没有前辈指引，不知道是对是错。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题学习记录]]></title>
    <url>%2F2018%2F06%2F08%2Fnote-leetcode%2F</url>
    <content type="text"><![CDATA[遇到的子问题： 二维数组（矩阵）优雅地按行遍历 12345int C = A[0].length;for (int[] row: A) for (int i = 0; i &lt; C; ++i) &#123; ... &#125; 易错点 对于数组问题，经常把数组的内容索引不区分开，如i与a[i]。只要是索引，大多数情况应有符号。 算法优化 是否能替换为位运算？ 涉及奇偶，for循环可否变为i+=2？ 无解时的思路数组 尝试排序？ 涉及多个数组，遍历比较短的数组可以防止越界问题。 如果for循环遍历不方便，不妨试试while。 位运算专属题目- 计算一个二进制序列有多少个1123int count = 0;for (int i=0;i&lt;32;i++) count += (xor &gt;&gt; i) &amp; 1; 原理：如何判断某位是1？，则&amp;1的结果是1。 或者 12345int count = 0;while (xor != 0) &#123; xor &amp;= (xor - 1); count++;&#125; 原理：每次一个xor &amp;= (xor - 1);都消去最后一个1。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180608]]></title>
    <url>%2F2018%2F06%2F08%2Fdiary20180608%2F</url>
    <content type="text"><![CDATA[12:24:41 这两天高考，一如既往有很多新闻。打算下午再去一次海底捞看看。 12:35:15 我发现自己已经养成了一个技能。每当心情低落，因琐事而难过，都会告诉自己，这是生理上的化学反应。不过是大脑中的那些化学物质，让我本能地逃跑而已。这样想着，就会好很多。 14:55:05 第一次听到乌鸦叫的声音。应该不能说第一次，只是以前没注意过。“呀——呀——”的叫声，真的很难听，很烦人。 19:45:37 去了海底捞！吃的蛮开心。海底捞的服务仍然十分出色，但是这次没人帮忙涮菜。然后赶在5点前付款，340多块钱的优惠了108块！ 20:22:53 没人能拯救我 除了我自己 23:48:06 明天把毕业论文打印。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用软件下载地址]]></title>
    <url>%2F2018%2F06%2F07%2Fthought-favorite-software%2F</url>
    <content type="text"><![CDATA[软件 链接 vscode https://code.visualstudio.com/docs/?dv=win git https://git-scm.com/download/win 坚果云 https://www.jianguoyun.com/static/exe/installer/NutstoreWindowsInstaller.exe 有道词典 http://cidian.youdao.com/download/YoudaoDict.exe 有道云笔记 http://download.ydstatic.com/notewebsite/downloads/YNote.exe 360 https://down.360safe.com/inst.exe 360解压 http://dl.360safe.com/360zip_setup_4.0.0.1080.exe 360极速浏览器 http://down.360safe.com/cse/360cse_9.5.0.132.exe 微信 http://dldir1.qq.com/weixin/Windows/WeChatSetup.exe 福昕阅读器 http://file.foxitreader.cn/file/Channel/reader/foxit_FoxitReader_CHS_9.2.0.35791.exe potplayer http://get.daum.net/PotPlayer64/Version/Latest/PotPlayerSetup64.exe XMeters https://entropy6.com/xmeters/downloads/XMetersSetup.exe Everything http://www.voidtools.com/Everything-1.4.1.895.x86-Setup.exe 小米云客户端 https://land.xiaomi.net/res/c37feea8/other/MiCloud%20Setup%200.1.24-ia32.exe 百度网盘 http://issuecdn.baidupcs.com/issue/netdisk/yunguanjia/BaiduNetdisk_6.2.0.exe TIM https://dldir1.qq.com/qqfile/qq/TIM2.2.0/23808/TIM2.2.0.exe QQ https://dldir1.qq.com/qqfile/qq/QQ9.0.3/23756/QQ9.0.3.exe 搜狗输入法 http://cdn2.ime.sogou.com/afdf66e02f22b0123f7bd1cd23beb5be/5b18c2a2/dl/index/1527229887/sogou_pinyin_90b.exe minGW-w64 https://cytranet.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe intelliJ idea https://www.jetbrains.com/idea/download/download-thanks.html?platform=windows Ditto https://sourceforge.net/projects/ditto-cp/files/Ditto/3.21.223.0/DittoSetup_64bit_3_21_223_0.exe/download honeyview https://dl.bandisoft.com/honeyview/HONEYVIEW-SETUP.EXE mysql https://cdn.mysql.com//Downloads/MySQLInstaller/mysql-installer-community-8.0.11.0.msi sqlyog https://www.webyog.com/downloadtracker?wy=1706601&amp;pType=EXE&amp;bit=64 python3 https://www.python.org/ftp/python/3.6.5/python-3.6.5-amd64.exe node.js https://nodejs.org/dist/v8.11.3/node-v8.11.3-x64.msi chrome https://www.google.cn/chrome/ 网易云音乐 https://music.163.com/api/pc/download/latest]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180607]]></title>
    <url>%2F2018%2F06%2F07%2Fdiary20180607%2F</url>
    <content type="text"><![CDATA[23:54:58 今天白天把电脑重装了，下午到图书馆看了看书。看到文学区，老舍，胡适，丰子恺，史铁生。他们的散文大多是日记或游记，阅读他们的作品，好像在与他们直接对话。 记录下今天在图书馆的思考。 刷题，为别人讲解，是最好最快的学习方法。 通过学信息安全来学操作系统和计算机网络。 追求三个境界： 正确写出程序 快速写出程序 不断优化性能 游戏是各种技术的综合。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180606]]></title>
    <url>%2F2018%2F06%2F07%2Fdiary20180606%2F</url>
    <content type="text"><![CDATA[0:07:58 即将答辩，将会是什么场面呢？ 0:49:47 答辩结束，如想象般平常。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180605]]></title>
    <url>%2F2018%2F06%2F05%2Fdiary20180605%2F</url>
    <content type="text"><![CDATA[13:41:55 来到久违的库可咖啡，喝了久违的卡布奇诺。 今天早晨起来突然就觉醒了。对自己哪里不满意，改就是了。只不过要意识到，自身任何方面的改变、改良，都是一个长期的过程。时间没到，没有看到反馈，自然就会难以坚持。要耐心，要看的远。 13:50:56 库可咖啡这里网速是真好，但是太热了。。 22:44:08]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180604]]></title>
    <url>%2F2018%2F06%2F04%2Fdiary20180604%2F</url>
    <content type="text"><![CDATA[15:31:03 来到书香斋。没有抢到好地方。左肩酸痛。开始制作答辩ppt。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180603]]></title>
    <url>%2F2018%2F06%2F03%2Fdiary20180603%2F</url>
    <content type="text"><![CDATA[13:28:35 昨天晚上喝了很多，昨晚睡得还不错。但仍然觉得时间过了很久。 0:09:08 下午本来打算去海底捞，到那里发现需要排两小时的队。于是转战佰烧，扶着墙进扶着墙出。晚上回家，跟胡、浩去了网吧。与预期一样，没有什么好玩的。我不爱玩游戏这个毛病看来是改不了了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180602]]></title>
    <url>%2F2018%2F06%2F02%2Fdiary20180602%2F</url>
    <content type="text"><![CDATA[22:35:10 今天拍了一天的毕业照，晚上跟班里吃烧烤，喝酒，觥筹交错。心病仍存。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180601]]></title>
    <url>%2F2018%2F06%2F01%2Fdiary20180601%2F</url>
    <content type="text"><![CDATA[15:13:01 来到毓秀楼自习室。 昨天晚上玩了会儿战地1，相当不错。然后就是今天起床时很累。 今天六一儿童节，又一波朋友圈。 收到论文修改意见，改了一些不痛不痒的格式问题。 18:26:01 最好的训练方式是封闭，集中，多人。学弟在acm校队，一练就是一天，收获自然非常多。 19:35:07 如果学习任务不明确，最好的方式是去封闭人多的场所。如果明确，则可以到空旷适宜的畅所。 20:14:53 人生没有幸福，只能尝试避免悲伤。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人生节点]]></title>
    <url>%2F2018%2F05%2F31%2Fdiary-big-events%2F</url>
    <content type="text"><![CDATA[以此记录人生中值得记录的节点，方向从底向上。 2018年 6月2日 拍毕业照，班级最后的聚餐 5月26日21:30:00~27日16:20:00 湖大黑客马拉松 5月26日19:00~21:30:00 毕业晚会]]></content>
      <categories>
        <category>日·记</category>
      </categories>
      <tags>
        <tag>大事记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180531]]></title>
    <url>%2F2018%2F05%2F31%2Fdiary20180531%2F</url>
    <content type="text"><![CDATA[9:15:40 梦见语文老师让写一天一练，我忘了写，被罚一周，骂骂咧咧的醒来。 16:24:41 看了一下午小米新品发布会，小米8探索版很酷。 16:25:13 每每遇到招聘，心里都会打鼓。怎样才能在内心深处对自己有自信呢，至少在技术上？ 16:32:34 总结一下，我应当把每天用来编程的时间分成两种，一种是深入当前的方向，另一种则是跟随潮流。所谓当前的方向，基本就是每次面试都会问到的核心能力，操作系统，算法，其中操作系统中比较重要的概念是内存管理。而跟随潮流，则是尝试去追随当前热门的东西，或者好玩的东西，区块链，机器学习，前端等等。 16:42:06 发现了两个新的学习维度，一是关键字。把一门编程语言的所有关键字理解了，也就学会了这门语言了。二是错误反馈，如果不这样做，会发生什么？不能仅仅知道这样做会报错，还要知道这样做会报什么错。有必要专门总结一下。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180530]]></title>
    <url>%2F2018%2F05%2F30%2Fdiary20180530%2F</url>
    <content type="text"><![CDATA[15:54:44 在毓秀楼呆了一下午，尝试学一下Qt，来添加博客的图片上传功能。今天上午下了场非常大的雨。 20:44:53 下午帮邱素欣写了一个C++的程序，感觉很好。 21:22:15 把前几天的照片补一下。如果每天不把当天的照片补上，之后就几乎没有动力了。所以一定要尽可能自动化的搞定。 26号的毕业晚会的门票很好看，一个可动卡片和一个贴纸。晚会还是不错的。 毕业晚会当晚到超算中心救场，坚持到活动搞完，给了个参赛证明。 坚持30个小时，迈出大门，那一刻的感觉非常美好。那时候是27号的下午。 回到家后，昏昏睡去，从下午4点到晚上10点，太累了。晚上清醒了4个小时，2点又睡了，一直睡到第二天11点。当晚梦见了一个小学同学，这段梦成了接下来两天最美好的记忆。 早上醒来看到一些留言。希望都好，希望这种感情一直在，希望有一天能自信的见上一面，哪怕一面。 此时已是周一，下午还忘了去找王老师。 周二，29号，终于去一个叫做毓秀楼的新教学楼取回了三方，也发现了这个新的神奇的自习室。 今天的自习。 晚饭出来看到一个环卫工人，还有陪着她的小狗。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180529]]></title>
    <url>%2F2018%2F05%2F29%2Fdiary20180529%2F</url>
    <content type="text"><![CDATA[10:59:16 社会契约不是儿戏，想太多没有用。 14:12:15 真的有必要写个图片上传的客户端。 19:26:17 今天心情不错，一切顺利。 上午去新·新校区，毓秀楼，终于把我的三方取回来了。回来到文涛那里交材料，该交的都交了，原来团员证早就上交了一直没发下来。下午在毓秀楼看了几个小时的机器学习。晚上把论文打印完。 20:48:21 学习任何一个领域的新知识，都至少坚持一个星期。这两天尝试搞机器学习，真心需要坚持。 21:20:33 发现node.js挺有趣的，学习一下。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180528]]></title>
    <url>%2F2018%2F05%2F28%2Fdiary20180528%2F</url>
    <content type="text"><![CDATA[13:46:25 来到凯李，占到了最好的位置。 昨天下午4点多从超算中心回家，毕竟精神了30个小时，直接躺床上睡着了。晚上10点多醒来，盖好被子，大概2点多又睡了。做了一个梦，简直是有生之年最好的梦了。 这两天过得像过了一个星期。先是毕业晚会，然后去黑客马拉松的活动，还有昨天的美梦，还有一些留言，都很值得回忆。但是有些也只能回忆了。 17:00:46 看了自己在2013年写的一篇日志。我原以为我删了，或者至少是设置仅我自己可见。原来是指定好友可见，只有你一个。现在不是好友了，但还这样设置着。就这样吧。 我怀念那时的自己，傻逼但充满干劲；现在可能相反了，不太傻逼，但变得有些畏首畏尾。 17:11:42 感谢，感谢共同拥有的记忆，带领你时常到梦里陪我。但我能做的也只是不去打扰，过更好的生活。同愿三冬暖，亦祝春不寒。 18:14:58 给博客增加了一个带www的域名。 2:08:35 阴阳差错下载了当年十佳班长的视频，看到十秒就看不下去了，太羞耻了。。。不过仍然保存了起来。真好啊，肆无忌惮的年纪。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180527]]></title>
    <url>%2F2018%2F05%2F27%2Fdiary20180527%2F</url>
    <content type="text"><![CDATA[14:13:27 毕业晚会，开头和结尾，眼睛确实是模糊的。 14:17:44 最终还是来到超算中心救场，帮几个学弟学妹熬完黑客马拉松。从昨晚到现在，我以最高精力熬了一宿，还结交了几个非常靠谱的学弟。当进入那种专注的状态时，精神集中的让我自己都害怕。最终没有到达终审，但是我从未想过自己能这么快的解决问题。很满足。现在在观望其他选手。 14:26:13 看到了一些留言，难以平复。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程语言创造日记]]></title>
    <url>%2F2018%2F05%2F26%2Fnote-language-create-log%2F</url>
    <content type="text"><![CDATA[尝试使用语言 helloworldprint(“helloworld”); 函数的定义： 读取文件，读取字符串，如果]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180526]]></title>
    <url>%2F2018%2F05%2F26%2Fdiary20180526%2F</url>
    <content type="text"><![CDATA[12:06:36 来到凯李咖啡。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180525]]></title>
    <url>%2F2018%2F05%2F25%2Fdiary20180525%2F</url>
    <content type="text"><![CDATA[19:02:19 收拾完毕业设计一堆东西。填了华为的报道单。 1:01:41 看了《C Primer Plus》，这书写的真好，翻译的真好。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统——数据的结构与表示]]></title>
    <url>%2F2018%2F05%2F25%2Fnote-os-data%2F</url>
    <content type="text"><![CDATA[无符号数首先，操作系统中所有数据本质上以二进制存储。 每一串二进制值序列都可以通过一定的逻辑看做为一个十进制值。如二进制的0101就是十进制的5。这实际上就是“无符号”（unsigned）编码，其中的计算过程被称为B2Uw，即Binary to Unsigned,w是长度。 例如，B2U4([1011])=11,即每个数位乘以2的n次方相加，n依次至0. 易知，无符号数的取值范围为[0,2w-1]。 补码补码的英文是“two’s-complement”，意味“二进制的”]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程语言概念]]></title>
    <url>%2F2018%2F05%2F25%2Fnote-language-common%2F</url>
    <content type="text"></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言环境问题总结]]></title>
    <url>%2F2018%2F05%2F25%2Fnote-c-env%2F</url>
    <content type="text"></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180524]]></title>
    <url>%2F2018%2F05%2F24%2Fdiary20180524%2F</url>
    <content type="text"><![CDATA[12:16:44 今天学校体检。 13:13:17 赶紧把参考文献补齐。。 15:19:07 体检完毕。面对同学，我毫无自信站立，每时每刻都想躲开。身上的衣服大概一个月没换了。如果以后谁看到这句话，请不要惊讶。希望我自己在一两年后看到这句话时，不会是同样的感受。 20:49:50 今天明白了一些事情。 在体检时，我再次体会到那种不安的感觉。我去晚了几分钟，文涛告诉我，由于许莹填她自己的体检表时填错了，而表是不可更改且数目有限的，就用了一张新的，意味着我没有表可用，只能暂时拿着许莹填错的那张表。这没啥。之后看到班里的同学，男生女生，我的头上瞬间像有千斤顶，压得脖子痛。我的自尊已经在心里自暴自弃，像一个打了败仗的将军，屡败屡战，直到绝望，再也没有了士气。 这当然是因为我的头发，还因为我愈加臃肿的身体，还有身上好久没洗的衣服，还有别人当然轻易闻不到的臭汗。 大概半小时前终于把毕业论文写完，我突然明白了，一种使命感涌了上来。 我之前以为我需要用身价、职业、工资来证明自己存在，试图把签约的公司名称当做敌人首级献给我的自尊心。然而我错了，工作确定后我的心情并没有好转，反而变得更加自卑。这种自卑是自然的，少时不知天高地厚到大学见了世面，期待感的提高没有配上自身的进步。我终于意识到，我的自卑，来源于不自信。 多奇怪的说法，自卑来源于不自信？是的，我不是因为外貌或身价之类的“容易”自卑的事情，而是因为多方面综合引起的“不自信”。我并不从心底热爱编程，只是因为蓝杰这个群体中的牛人太过耀眼，我不想仅仅被照耀而已；另外，我似乎也没有其他路可走。这导致了我到如今仍然会不实际地对比自己与业界大牛的差距，这差距会让我失落。我经常给自己某个理由，为了专注于某件我不喜欢的事情，我可以慵懒或放飞自己，暴食、看片，好像跟我大二时很像？久而久之，我不再敢照镜子，这会让我免受自己的恶心。 毕业论文结束之后，我再也没有了理由。我在很久以前也会如此，经过任何仪式性的事件之后，我会把自己收拾的精致一些，然后立刻恢复颓废状态。现在看来，那是因为我没有找到生存的意义。 现在有了，那就是在现实这款开放世界游戏中找到最终的宝藏——我的自信。人生的每一天都是一个关卡，每个关卡都非常相似，只是自问自答的一个小问题：“如果现在发生……，我会自信地面对吗？”如果作出的回答是“是”，恭喜我自己，我今天过关了。如果是否，很遗憾，今天是没有意义的一天。 如果现在有朋友来到我的房间玩，我会有自信接待他吗？ 如果有朋友约我去游泳池，我会有自信去吗？ 如果现在让我跟班里某个女生做两节课的同桌，我会有自信持续下去吗？ 如果我的女朋友想亲吻我，我会有自信不躲避吗？如果不是亲吻呢？ 可笑的问题！但答案都是否定的，都他妈是否定的。 这不是散文，不需要有什么完美的结尾。按照这个思路度过接下来的每一天，看看会有什么改变吧。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180523]]></title>
    <url>%2F2018%2F05%2F23%2Fdiary20180523%2F</url>
    <content type="text"><![CDATA[11:30:01 来到凯李咖啡。这里的绿茶是泡茶包，红茶是泡茶叶。昨天看到雷蛇新发布的游戏本，极其轻薄极其强劲，就是贵。以后有钱了要入手。 11:36:00 尝试在桌面环境下隐藏任务栏，也许可以更专注。好吧，非常有效！ 16:42:22 肩膀酸痛，打道回府。 18:02:40 生活可以多绝望？打道回府吃了晚饭回到家发现电源线落下一半在咖啡店！ 18:28:35 取回来了。 18:28:57 来回的路上急躁而不顾行人，感觉有点刺激。也许最适合我的状态是战士，而非艺术家。 18:31:57 检查了一下前天老师指出的论文的问题列表，发现基本都解决了。 0:47:17 今天大概是有史以来打字最多的一天。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用例规约案例]]></title>
    <url>%2F2018%2F05%2F22%2Fnote-se-usecase-example%2F</url>
    <content type="text"><![CDATA[题目：某生物研究室希望通过放射线来改良稻种，所以决定用不同剂量的射线照射不同稻种来研究变异情况。放射源放在一个深井里，实验进行时把放射源升上来，试验完毕降下去。由于放射性很强，不允许放射源升起时有人在放射室内，但研究人员希望能在实验进行时监控实验进行的情况。技术人员提出了一个方案:系统打算分服务器端和客户端，服务器端有一个USB摄影头，用来捕捉现场视频。客户端可向服务器发出请求，请求其现场视频数据，服务器收到请求后，将从USB摄影头捕捉到的视频进行编码，然后发送给客户端。客户端收到视频数据后先解码，然后在本地播放。服务器和客户程序之间的会话和视频流数据的传送采用RTSPRIP协议。 下面是开发人员一开始写的用例规约，请分析其中的问题并加以改进。 123456789101112131415161718192021UC1:播放视频执行者 研究人员(主)前置条件、后置条件略涉众利益 研究人员:希望看到视频;希望有尽可能多的可选范围(不同的地方以及同一地方的不同视角);希望操作简单。 客户端:希望网络稳定基本路径1. 研究人员在客户机上请求播放视频2. 研究人员输入连接参数3. 客户机系统检查连接参数4. 客户机系统请求和服务器系统建立通讯连接5. 服务器系统确认客户机系统的连接请求6. 服务器系统增加连接计数7. 客户机系统显示视频播放窗口8. 服务器系统启动视频采集9. 服务器系统对视频数据编码10. 服务器系统发送视频流11. 客户机系统接收视频流12. 客户机系统对视频流解码13. 客户机系统在视频播放窗口播放视频 问题指出1.用例编号和用例名不规范。应该改为： 12用例编号：UC1用例名：播放现场视频 2.前置条件和后置条件不应忽略。应该改为： 1234前置条件： 无后置条件： 客户端完整播放现场视频 3.涉众利益描述不规范，应该是人而非“客户端”之类的抽象实体；应当描述为涉众的想法而非技术要点；应当有恰当的排序；“希望有尽可能多的可选范围”应当写在一个或多个单独的用例规约中应该改为： 1去掉“客户端:希望网络稳定”等。 4.基本路径的问题 应当将整个系统视为黑箱，不应出现涉及“服务器，客户端”的冗余描述； 网络参数应当作为前置条件。 改正结果12345678910111213141516用例编号：UC1用例名：播放现场视频前置条件： 网络参数已经设置完毕后置条件： 无涉众利益： 研究人员:担心看不到视频；担心操作复杂基本路径: 1. 研究人员请求播放现场视频 2. 系统显示视频播放窗口并播放视频扩展路径： 1a. 网络无法连接，无法播放视频 1a1. 系统提示网络参数错误，需要重新设置非功能需求： 视频应当至少达到720p的清晰度 1234567891011用例编号：UC2用例名：以不同视角播放现场视频前置条件： 系统已打开视频窗口并播放视频后置条件： 无涉众利益： 研究人员:希望有尽可能多的可选范围(不同的地方以及同一地方的不同视角)基本路径: 1. 研究人员请求以某种视角播放视频 2. 系统按指定视角显示视频播放窗口并播放视频 参考资料：《软件方法（上） 业务建模和需求》]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180522]]></title>
    <url>%2F2018%2F05%2F22%2Fdiary20180522%2F</url>
    <content type="text"><![CDATA[14:10:40 来到凯李。今天天气出奇的凉快。 14:50:55 计算机学科复杂而多样，每个方向的精通都需要付出巨大的成本。如果不是从小就对某个方向拥有浓厚兴趣，后天很难完全靠兴趣来培养专业能力。有一种思路值得思考：如果十年后从技术转（技术）管理，现在应该拥有什么能力，应该培养什么能力？我觉得应当是开发效率、大型（复杂）软件的架构，人员配置，甚至人脉积累。细化到具体的学习方向，扎实的基础+一专多强的知识面，应当是努力的风向标。 16:19:42 现在才明白，微软的to-do实际上是任务驱动，最终目的是将圆圈画勾。 0:30:42 如果想的太多，放不下的太多，就去听音乐吧！]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[巨人的肩膀——优秀者是怎样学习的？]]></title>
    <url>%2F2018%2F05%2F21%2Fnote-study-experience%2F</url>
    <content type="text"><![CDATA[作者：逸文奥特曼链接：https://www.zhihu.com/question/268475346/answer/338387150来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 谢邀~,题主我跟你一样,现在大四,当初大二的时候看到知乎有关写os的课程,感觉非常有趣又可以深入理解底层知识. 于是我大二下学期开始自学os课程,先看了os的理论书(现代操作系统跟csapp),接着想着应该可以写os了吧,毕竟我也会c/c++,然后看学堂在线的ucores..结果lab做的很艰难,觉得自己基础很不扎实. 于是在知乎的推荐下,开始学汇编(王爽汇编语言),然后学习32位汇编跟x86的保护模式(非常推荐看李忠的x86从实模式到保护模式,谁用谁知道),然后买了一本unix内核源码剖析,看了这本书发现用的是pdp11汇编,过于古老,然后查到mit基于x86重写了unix v6,就是现在的xv6,具体如何学习xv6可以看这,很多人已经推荐了,知乎用户：如何结合xv6 book来阅读xv6源代码？ ,然而我英文实在是惨不忍睹,没能坚持下去(题主别学我). 然后搜到一本操作系统真象还原,然后感觉跟见了宝一样,疯狂的跟着书做实验写代码,从mbr,bootloader到内存管理,进程线程的创建,进程调度,文件系统最后实现带命令行的shell2个半月读完并自己写代码实现书上的功能(这里有我对这本书的评价:又一本国人写的精品的计算机书籍),回首发现自己对整个os的运行机制有了重新的认识,这种感觉爽爆了. 然后自己开始膨胀了,看看看Linux内核了,在豆瓣搜了几本内核书,一本linux内核设计与实现,一本毛德操的Linux内核源代码情景分析,学习毛德操老师的这本书是最艰苦跟最难啃的,这书写得很枯燥，讲述代码细节的部分太多了，总是晕头转向,第一遍看到第三章就放弃了,第二遍就除了文件系统这块,这本书的上册总算慢慢啃啃完了(由于大四拿到offer后各种浪也不去实习了,很多知识点都忘了,毕竟只是看Linux2.4内核并没有动手实践,这点是我做的非常不对的地方) 另外一本Linux内核设计与实现比较薄,写的不纠结内核代码本身，而是把握了内核设计的思想及精华所在,解释的也很到位.,然后到了大三下学期开始投简历了,把自己模仿写的简易os写上去,还有读Linux2.4内核的博客笔记也写到简历上去了,然后成功拿到了offer2017年自己的腾讯春招面经,实习时做的是对底层框架的优化跟重构,由于自己对底层的了解,底层框架性能也提升了不少,由此也成功转正并拿到了ssp offer. 我回忆这段经历都觉得写一个os对我的帮助远远超出其他课程.由此我觉得本科阶段很有必要自己实现一个os内核~ 1.编码2.c语言程序设计，c语言之父那本3.csapp4.sicp5.调试9法6.离散数学，国外著名的那本7.计算机网络自顶向下方法8.tcpip 卷19.lwip相关书籍10.虎书11.编译原理12.Ucos相关书籍13.Linux 0.11 赵囧那本14.Linux源代码 毛德操那边14.5 head first python15.代码大全16.修改代码的艺术？17.工作日保证4个小时看书时间18.每天跑步5公里，23点之前睡觉，6点起看书19.和同行多交流，多沟通20.少刷知乎ps: 一遍看不懂就多看几遍，有习题的要做习题 作者：jack lee链接：https://www.zhihu.com/question/43440229/answer/111548738来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 有哪些信息安全方面的经典书籍？ - 黄博文的回答 - 知乎https://www.zhihu.com/question/21390646/answer/24488156]]></content>
  </entry>
  <entry>
    <title><![CDATA[diary20180521]]></title>
    <url>%2F2018%2F05%2F21%2Fdiary20180521%2F</url>
    <content type="text"><![CDATA[12:38:43 其实可以直接右键git bash直接打开命令行，不一定要powershell。 12:42:57 好吃点的粗粮饼干当饭吃一点问题没有。 16:10:47 毕设进展顺利，胜利在望！]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180520]]></title>
    <url>%2F2018%2F05%2F20%2Fdiary20180520%2F</url>
    <content type="text"><![CDATA[13:06:48 来到凯李。以后应该尝试习惯最小化而非关闭。 14:48:13 论文]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180519]]></title>
    <url>%2F2018%2F05%2F19%2Fdiary20180519%2F</url>
    <content type="text"><![CDATA[12:34:53 来到凯李咖啡。 把任务栏又移到了右边。 13:43:57 目前而言，最好的“尽快完成不喜欢的事情”的办法就是听一些语调平静但富有力量的钢琴曲，比如《Fight Against Myself》。 21:40:32 音乐是饥饿感官注意力的转移。 22:55:38 刷知乎，逐渐感觉计算机图形学是一个非常锻炼人的方向。第二次看到轮子哥的计算机三大浪漫：操作系统，编译原理，计算机图形学。之后可以尝试下。 0:26:10 有的时候真的怀疑，冥冥中有一个控制命运的人，偶尔就会捉弄我一下。白天在凯李咖啡见到一个穿着粉色衣服瘦瘦的哥们走出门，看起来像何子琪。我给他发了qq，他说他在寝室。如此简单的对话。晚上从凯李回家，琢磨着吃点什么，在临下坡前买了炒饭，回头发现有人叫我，竟然就是何子琪！上来第一句话就是问候我的发际线，我一时不知如何是好。我上次见他已是几个月之前，没想到这次见面的方式如此偶然，又如此巧合。真的好像被命运捉弄。 如果真有命运的话，感谢你，让我得了一种的绝症。不痛不痒，而痛苦至极的绝症，也大概只有这一种了吧。 0:41:22 果然写作对技术人员的发展是有大大的好处的。。计划开始写博客了。 0:54:42 操作系统，编译原理。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UML学习笔记]]></title>
    <url>%2F2018%2F05%2F18%2Fnote-diagram-uml%2F</url>
    <content type="text"><![CDATA[UML类图类之间关系 泛化(generalization) 实现(realize) 聚合(aggregation) 组合(composition) 关联(association) 依赖(dependency) 泛化与实现 泛化： 代码中表现为继承非抽象类。子类是父类的一种(is-a)，且父类和子类都是具体的，现实中有模板的。 如：汽车——福特牌汽车。 图例为实线空心三角。 实现： 代码中表现为继承抽象类。子类是父类的一种，且父类无法直接描述。 如：车——客车，车——卡车 图例为虚线空心三角。 聚合与组合 聚合 表示整体由部分构成，且整体消失后部分不会消失，即非强依赖关系。其中整体一般为人所理解的抽象概念。 如：部门——员工，班级——学生 图例为实现空心菱形 组合 表示整体由部分构成，且整体消失后部分也消失，即强依赖关系。均为人所理解的抽象概念。 如：公司——部门，学校——班级 图例为实线实心菱形 关联与依赖 关联 代码中表现为类成员变量。表示不同类之间的静态的关系（名词），通常与运行状态无关，用来定义天然的结构，是一种“强关联”的关系。 如：人——火车票，学生——学校 关联不强调方向，表示对象间相互知道彼此的存在；如果存在方向，如A–&gt;B，则A知道B，B不知道A。 图例为实现，或者实现加箭头。 依赖 代码中体现为类构造方法以及方法参数。描述一个对象在运行时会使用另一个对象（的方法或属性）。与关联的区别在于，依赖是一种临时性的关系，通常在运行期间产生，运行状态改变也许会改变依赖关系。 图例为虚线加箭头，箭头所指方向为调用关系。 参考博客http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>diagram</tag>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志框架学习]]></title>
    <url>%2F2018%2F05%2F18%2Fnote-java-logger%2F</url>
    <content type="text"><![CDATA[SLF4JSLF4J全称：Simple Logging Facade for Java，简单日志门面 用户手册链接：https://www.slf4j.org/manual.html]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需求分析与系统设计]]></title>
    <url>%2F2018%2F05%2F18%2Fnote-se-requirements-analysis-and-system-design%2F</url>
    <content type="text"><![CDATA[一、整理需求列表例： 用户可以通过“客户名称”关键字进行模糊查询 单击“新增”按钮，进入“新增客户”界面，可新增客户基本信息 …… 二、系统设计 分析原始需求，找到涉及的用例（Use Case） 涉及表结构 定义URL规范 三、设计用例如： 查询客户 显示客户列表 创建客户 编辑客户 …… 可用UML图来描述用例。 四、设计表结构 字段名 数据类型 是否非空 字段备注 id BIGINT √ ID(自增主键) name VARCHAR(255) √ 客户名称 email VARCHAR(255) - 邮箱地址 五、设计界面原型典型管理系统如： 六、设计URL如： 序号 URL 描述 1 GET:/customer 进入“客户列表”界面 2 POST:/customer_search 查询客户 3 GET:/customer_show?id={id} 进入“查看客户”界面 4 GET:/customer_create 进入“创建客户”界面 5 POST:/customer_create 创建客户 6 GET:/customer_edit?id={id} 进入“编辑客户”界面 7 PUT:/customer_edit?id={id} 编辑客户 8 DELETE:/customer_delete?id={id} 删除客户 用例规约用例规约的内容 前置条件和后置条件 涉众利益 基本路径 扩展路径 补充约束 前置条件和后置条件定义前置条件：用例开始前，系统需要满足的约束 后置条件：用例结束后，系统需要满足的约束 后置条件分为两种： 最小后置：用例失败的情况下系统也需要满足的要求 成功后置：用例成功时系统需要满足的约束 要点 前置条件、后置条件必须系统可以检测到。 前置条件必须在用例开始前系统就可以检测到。 前置后置条件是约束，不是动作。 前置后置条件必须要精确。 涉众利益定义设计系统时涉及某些角色的利益。 要点如何寻找涉众？如果这个系统的用例做不好，谁会遭殃？ 执行者 上游 下游 信息的主人 给涉众排位基本路径定义用户与系统的交互过程 要点 按照交互四部曲 （执行者）请求 （系统）验证 （系统）改变 （系统）回应 使用主动语句理清责任 主语只能是主执行者或系统 使用核心域概念 不要涉及交互涉及的细节 扩展路径定义基本路径上系统要处理的意外和分支 要点经常发生的地方 执行者的选择 系统验证 关键步骤失败 补充约束定义路径步骤中需要补充的内容，如字段列表或业务规则 要点]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180518]]></title>
    <url>%2F2018%2F05%2F18%2Fdiary20180518%2F</url>
    <content type="text"><![CDATA[14:25:59 来到凯李咖啡。 最近早上起床很晚，有时候刷微博刷别的很快就消耗很多时间。 我才发现我可能在精神上也需要减一下肥。精神得不到补充，就会难以停止地阅读、浏览无用的信息，像极了饥饿时的人；消耗的时间变多，精神反而不佳。而真正管饱的，是不易阅读、需要消耗脑力的东西；这个过程类似健身，难以坚持但会渐进地快乐。 15:22:34 如果垃圾文字或视频是高热高糖的垃圾食品，音乐就是美味健康的粗粮饼干。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程常用配置文件快速参考]]></title>
    <url>%2F2018%2F05%2F18%2Fquick-configfiles%2F</url>
    <content type="text"><![CDATA[web.xml1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt;&lt;/web-app&gt; pom.xml1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180517]]></title>
    <url>%2F2018%2F05%2F17%2Fdiary20180517%2F</url>
    <content type="text"><![CDATA[13:32:35 在凯李咖啡。今天这温度，大概是上帝一家子在吃烤肉饭吧。 18:03:56 偶然刷到一条朋友圈，我突然发现了对自己激励/刺激最大的事情，是雄性竞争。我相信就算我有诸多缺点，世界上比我不幸、或者比我不受欢迎的人仍然很多；与此相对，世间也存在着诸多我遥不可及的雄性。这是如此客观的事实，我在上高中的时候就已经感受到那种，无论我怎么努力都无法追上别人的感觉；不只是成绩，财富、外表、发展潜力都是。怕就怕在这种人就在我身边，广义来讲就是朋友圈；更可恶的是他是同龄人，甚至年龄更小。当意识到自己已经被其他同龄雄性完全碾压时，本能会让我退缩，这种退缩让我非常懊恼，我本能的自尊无法与本能的退缩兼容。当二者发生冲突，第三种本能就是奋斗欲。现在的我无法打败他，但我希望、也相信能在有一天能打败他。我称这种心态，是一种被激励的心态。 相信不代表成真，希望不一定会换来真实。这像一道精神伤疤，不会疼痛，但难以磨灭。 23:36:22 跟政视频了一个半小时，相聊甚欢。 1:19:17 学习是一个递归的过程。在某本书里看到某个概念，则去查资料学习；查新的资料后会遇到新的概念。层层递归，如果在某个环节卡壳，心理会很不爽；如果能触及“递归终止”条件，即没有再遇到新的概念，且“递归返回”时同样顺利，则会学的很爽。避免卡壳的方法是，跳跃这个递归点，概念上了解，以免耽误时间，或者影响心情。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180516]]></title>
    <url>%2F2018%2F05%2F16%2Fdiary20180516%2F</url>
    <content type="text"><![CDATA[13:41:59 来到凯李咖啡。今天仍然十分热。 13:53:59 对面坐着一中年男一年轻女，男的气质像个中年司机，皮肤黑声音大，言谈却像一个老师，女的在向他咨询类似心理学求学的问题 男的边看电脑边讲心理咨询师的面试题：你是心理医生，有一个关系非常好的闺蜜，从小长到大；你喜欢一个年龄挺大的男人；有一天你的闺蜜跟你诉苦，一个男的跟她约会喝酒吃饭，酒后发生关系，她怀孕了，而那个男的正是你暗恋的男的。现在你闺蜜心里很乱，不知所措，向你求助，你该怎么回答。听着真有意思，只不过他们话太啰嗦了，而且声音巨大，想不听都不行。。 女生犹豫半天，说自己毕竟喜欢那男的，决定劝她们放弃。这大哥立刻反击说，“结果你闺蜜立刻说，我其实知道你喜欢那个男的，你之所以让我们放弃，是因为你喜欢他，你并非为了我好。你该怎么办？要知道一方面孕妇的心理不稳定，一方面事实上她已经揭穿你。你该怎么办？” 女生说她决定承认，但仍然决定劝她们分开，这是为了他们好。 男的开始总结。“你的问题在于，如果你喜欢的男的真的做出这种事，你还会喜欢他吗？”之类的。 男的开始第二个问题。你是学心理学的，现在你成了上述故事的闺蜜，你知道你闺蜜暗恋他。已经发生了这种事，男的说他并不是特别喜欢你，但会对你负责，你会怎么处理，孩子要还是不要？女生说不要孩子，找闺蜜，把这一切告诉她。男的问为什么要找她，闺蜜是不知道这件事的。女方坚定的要把孩子打掉，当什么都没发生过。男的说，这时候闺蜜不知为何知道了，质问她为什么 我开始觉得这位男性有一些水平了。他说，心理学研究问题时，要把所有情况考虑到，一步步分析和推测。我联想到二叉决策树。 他说，最好的做法是：“我是一个心理医生，不管她是谁，不管我与她是什么关系，我都尽我一个医生的职责。我会帮她做详尽的分析，帮她做情感和心理分析，帮她摆脱困境，始终把专业知识放在第一位。你的回答是在根据自己的目的，改变她的心理状态，怂恿她做你期待的事情，试图用你的专业的心理专业来左右你的病人的心理状态。这个问题清晰地探测出你是不是能当一个合格的心理医生。” 心理医生的三个“客观的态度，坚定的意志，敏锐的传达”。 你是当事人，所以你要有坚定的意志；你是心理医生，所以你要客观；你是咨询师，面对的是咨询者，你要敏锐地把你的专业知识传达给咨询者。 21:39:19 从炎热的室外回到住所，开着空调喝罐啤酒上网，感觉还是很舒爽的。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180515]]></title>
    <url>%2F2018%2F05%2F15%2Fdiary20180515%2F</url>
    <content type="text"><![CDATA[10:36:52 来到凯李咖啡。早上在85度C买面包，看到15、18元的全麦三明治，以后有钱了就吃这个。 16:32:29 我要买个小黄鸭，看看传说中的小黄鸭工作法有没有效。 18:50:27 帮我楠备份一份初心。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180514]]></title>
    <url>%2F2018%2F05%2F14%2Fdiary20180514%2F</url>
    <content type="text"><![CDATA[16:56:31 今天这温度真是绝了。可能是2018年最热一天。 上午因为三方填表的事情纠结了两三个小时。到最后发现想多了。 下午去检查毕设，压力比想象中小。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180513]]></title>
    <url>%2F2018%2F05%2F13%2Fdiary20180513%2F</url>
    <content type="text"><![CDATA[0:53:02 接连断了两三天的日记。 周五早晨满心欢喜与浩、胡去了河东看复联3，看完去吃了肉蟹煲，回来的路上就发现有点想放屁。下午一起去国金中心浪了几个小时，大约不到6点躺在卧室，感觉太累昏昏睡去，一直睡到10点多，下楼吃了蒜苗炒肉盖饭。此时已经开始断断续续打嗝，闻起来非常酸臭，我已经意识到又要犯病了。 回到卧室开始拉肚子。从晚上九十点一直到第二天凌晨5点，睡一会就得去厕所，且肠胃剧痛无比；一直到中午12点左右都没有好转——我是活活剧痛了半天。中午去了卫生站打了吊针，效果出奇的好，吊针打了半小时肚子就不太痛了。两小时之后买了点稀饭喝，回家后又睡去，直到刚刚。直到现在也没拉肚子了，只是略有腹痛。 算上这次，我一共犯了4次。前两次大概是在上初中时，在家犯的，肚子胀得厉害，打嗝放屁拉肚子，几天都没胃口。第三次是高中，应该是高二的某次开学，上吐下泻。时隔五六年，很久没再犯过了。这次时间短了很多，只是有那么半天的剧烈腹痛。现在好了很多。 睡眠真是容易消磨时间，总感觉昨天刚从河东回来。 毕业论文还没写完，要加紧了。 10:36:56 一觉起来，肚子不再胀气，打嗝也不酸臭了。看来已恢复。 15:08:20 与胡来到凯李咖啡。空调好评，但又困又累。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180510]]></title>
    <url>%2F2018%2F05%2F10%2Fdiary20180510%2F</url>
    <content type="text"><![CDATA[19:42:31 兜兜转转，最终来到凯李。给生哥发了邮件。尝试在江边看书，总有小虫让我分心。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180509]]></title>
    <url>%2F2018%2F05%2F09%2Fdiary20180509%2F</url>
    <content type="text"><![CDATA[1:41:27 困倦时更容易陷入崩溃。 我的头发快掉光了，我对此无能为力。 我没有患上什么可怕的绝症，仅仅是不痛不痒的遗传。尽管我早已预见会有那一天的到来，我仍然会偶尔因此而崩溃。 我不会痛哭，只会悲伤。每次到图书馆，忘记带校园卡的话，我会给保安看我的校园卡，上面有我高中时的照片。那个男孩的脸上有清晰的轮廓，眼神坚定，当然，头发健康。 从16年寒假，也就是前年开始，我在家陪奶奶聊天，她突然发现我有点掏鬓角。我不太相信，照了照镜子才惊恐地承认这一现实。从此，我时不时会把头发向上撩开，看着镜子端详自己越来越高的发际线。 尽管我从未有外貌上的自信，这仍是巨大的打击。我意识到我有一天会变成一个秃子，一个（也许是）胖、矮、丑陋的秃子，那是一副什么画面？ 我变得越来越不敢见人。我想我还存在着些心理防线，一遍遍告诉自己这不算什么；在和熟人相处时我勉强会暂时忘记，只是但凡与陌生人接触，我很难抬起头来。 我不自然的变得贪吃，满足食欲会让我暂时忘记这个现实；我更加不修边幅，尽管朋友好心提醒——对于一个矮胖还脱发的人，穿什么又有什么区别呢？ 不。。我不是在乞求读者的怜悯，没人能救得了我，除了我自己。哈哈，多好听的一句话。。 我能改吗 我改的了吗]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180508]]></title>
    <url>%2F2018%2F05%2F08%2Fdiary20180508%2F</url>
    <content type="text"><![CDATA[13:29:21 来到梅溪湖的漫咖啡。环境不错。 中午把新三方寄到华为武汉那边了。 14:33:24 漫咖啡价格不贵，服务]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180507]]></title>
    <url>%2F2018%2F05%2F07%2Fdiary20180507%2F</url>
    <content type="text"><![CDATA[19:23:18 来到凯李。今天检查毕设，微微有点慌。 接触了“面向组合子编程”的概念，深以为然。 20:06:37 搜了一下北京华为附近的房子，对租房的不确定稍有忧虑。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180506]]></title>
    <url>%2F2018%2F05%2F06%2Fdiary20180506%2F</url>
    <content type="text"><![CDATA[11:46:45 潮湿+高温，是最难受的。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180505]]></title>
    <url>%2F2018%2F05%2F05%2Fdiary20180505%2F</url>
    <content type="text"><![CDATA[13:01:57 索性在家运行pso的程序。还算有点成果。 14:03:37 人无计划则废。。。 0:25:14 与马行言愉快的聊了一会。 这个语气让我想起了与那个她分手前的对话。 可能对我来说，能有个人陪我聊聊都会很幸福。 被直呼其名“李斌同学”，是多么奢侈的待遇啊。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180504]]></title>
    <url>%2F2018%2F05%2F04%2Fdiary20180504%2F</url>
    <content type="text"><![CDATA[10:02:12 PSO程序没有出现意外，心理有些安慰。 14:12:03 依次来到库克和凯李。可以忍受微热，但无法忍受不通风。 21:51:06 翻到与许浩聊天的记录，值得记下。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180503]]></title>
    <url>%2F2018%2F05%2F03%2Fdiary20180503%2F</url>
    <content type="text"><![CDATA[13:55:19 其实不必偶尔怀疑人生的无趣。因为当人生真正有趣时，你不会去思考生活，留下的空余的时间，负面情绪的水平线就会慢慢上升。尝试忙碌起来，忙中会有乐。 19:45:15 来到凯李咖啡。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180502]]></title>
    <url>%2F2018%2F05%2F02%2Fdiary20180502%2F</url>
    <content type="text"><![CDATA[8:13:52 今天毕设检查，不知会不会有什么意外。 0:22:09 毕设检查没什么意外，只是需要加紧写论文了。 车有电，果然就会浪的飞起。中午去凯李咖啡，5点左右去河东吃了海鲜烧烤自助，又去一个高空咖啡坐了坐。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180501]]></title>
    <url>%2F2018%2F05%2F01%2Fdiary20180501%2F</url>
    <content type="text"><![CDATA[12:53:33 来到月亮咖啡。时间真快，5月份了。记忆再次断层，现在能想到的上一个节点，是去中科云华和去小米实习。 最近天气越来越热，很难找到一个舒服的咖啡店敲代码了。 早上去些许健了身。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180430]]></title>
    <url>%2F2018%2F04%2F30%2Fdiary20180430%2F</url>
    <content type="text"><![CDATA[14:48:57 把电动车的电瓶换了，爽。来到“画个月亮”咖啡。 世界上存在几种延长主观寿命的方式：早起，健身，在咖啡店度过一天。 18:37:07 因为某人欠钱不还的事情在咖啡店耗了一天。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从C语言到机器码]]></title>
    <url>%2F2018%2F04%2F29%2Fnote-c-compile%2F</url>
    <content type="text"><![CDATA[理论若干C语言文件到一个可执行文件，都经历了什么？ 预处理——预处理器（cpp，C Preprocessor）把源程序(.c)翻译为ASCII码中间文件(.i)。 编译——编译器（cc1）把ASCII中间码(.i)翻译为ASCII汇编文件(.s)。 汇编——汇编器（as,assembler）把汇编文件翻译为可重定位文件。 链接——连接器（ld，link data）把可重定位文件链接为可执行文件。 实例从源代码（.c）到汇编文件（.S）1gcc -Og -S test.c ## 从源代码到可执行文件文件1：main.c 123456789int sum(int *a,int n);int array[2] = &#123;1,2&#125;;int main()&#123; int val = sum(array,2); return val;&#125; 文件2：sum.c 12345678910int sum(int *a,int n)&#123; int i,s = 0; for(i = 0;i&lt;n;i++) &#123; s+=a[i]; &#125; return s;&#125; 使用cpp把C代码翻译成ASCII码中间文件： 12cpp main.c tmp/main.icpp sum.c tmp/sum.i 使用cc1把ASCII中间文件翻译为ASCII汇编文件： 12cc1 tmp/main.i -Og -o tmp/main.scc1 tmp/sum.i -Og -o tmp/sum.s 使用as把汇编文件翻译为可重定位目标文件 12as -o tmp/main.o tmp/main.sas -o tmp/sum.o tmp/sum.s 使用链接程序ld将两个可重定位目标文件组合起来，成为可执行目标文件。 1ld -o prog tmp/main.o tmp/sum.o 最终的目录结构为： 123456789101112.├── main.c├── prog├── sum.c└── tmp ├── main.i ├── main.o ├── main.s ├── sum.c ├── sum.i ├── sum.o └── sum.s 汇编与反汇编对于c文件main.c和mstore.c: 1234567891011121314151617#include &lt;stdio.h&gt;void multstore(long,long,long *);int main()&#123; long d; multstore(2,3,&amp;d); printf("2 * 3 --&gt; %ld\n",d); return 0;&#125;long mult2(long a,long b)&#123; long s = a*b; return s;&#125; 1234567long mult2(long,long);void multstore(long x,long y,long *dest)&#123; long t = mult2(x,y); *dest = t;&#125; 编译并汇编,得到a.out可执行文件： 1gcc main.c mstore.c 使用objdump(文件信息查看器)命令反汇编 1objdump -d a.out]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180429]]></title>
    <url>%2F2018%2F04%2F29%2Fdiary20180429%2F</url>
    <content type="text"><![CDATA[17:23:29 昨晚忘记给车充电。刚刚从凯李回来。学汇编还是要看C。 19:29:26 给博客加上了搜索功能。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180428]]></title>
    <url>%2F2018%2F04%2F28%2Fdiary20180428%2F</url>
    <content type="text"><![CDATA[17:05:59 今天早晨去了图书馆。学习了一把vscode。试图在河边看电脑，总有小虫不让我专心。 23:27:34 看纯黑直播打战神，有点感触。 动漫或游戏，角色觉醒，实力大增，小时候（甚至现在）我也会幻想自己在筋疲力尽时只要“一想”，就会立刻变强，但往往心有余而力不足。但是看着纯黑打游戏，最高难度下真是难上加难，稍有不慎就要重来；重来的次数增多，纯黑也不说话了，发挥也越来越好，最终通过关卡。其实玩家每当遇到困难关卡，屡败屡战后高度集中注意力的状态，也就是所谓的“觉醒”。这种觉醒来自于玩家对于自己“一定能通关”的期待，战死之后的失望和打击会转变为对自己无能的愤怒，在下次尝试时精神变得更加集中，身体（手指）的操作也更加灵活受控。 觉醒需要较高的期待，需要尝试的勇气，需要高度集中的精力。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180427]]></title>
    <url>%2F2018%2F04%2F27%2Fdiary20180427%2F</url>
    <content type="text"><![CDATA[12:14:49 差点忘记这个习惯。 18:33:24 大概是两小时前来到凯李咖啡。 21:15:31 为了查一个pso的文献来到图书馆。虽然没有在期待的书里查到，但总算查到了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180426]]></title>
    <url>%2F2018%2F04%2F26%2Fdiary20180426%2F</url>
    <content type="text"><![CDATA[15:37:59 记录一下上海的见闻。 现在回想起来，应该是无处不在的老外，西装革履，油头粉面；无处不在的商场酒店，偶尔遇到的推销小哥小姐姐。 楼高，路窄，车豪，人美。 道路非常干净，总像刚刚用水冲刷过一样。 外滩很美，真实的成现在眼前时，确实动容。。。 这是一座财富的城市，到处都是商品和货币的味道。匆忙的人群，精炼的外表。 鹏锅依旧气定神闲，基锅依旧犀利。鹏锅请我和基锅吃了好吃的，喝了好喝的，逛了好玩的。 代表性的，有个酒吧，牌面是明晃晃的“PUCK”。大概是park和fuck的组合，下面一行小字，什么什么and girls。上海人大概很多都比较直接吧。。 听鹏锅讲了些历史，一战前后的上海，各国强租，反倒让上海发展起来。脚底下每一寸都是金砖。 去广州那次说是高楼大厦治好了我的颈椎病，这次去上海应该能让我完全康复了。 这个世界，真的还有很多值得去探索，有很多等着我拥有……]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180424]]></title>
    <url>%2F2018%2F04%2F24%2Fdiary20180424%2F</url>
    <content type="text"><![CDATA[7:17:35 出发。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180423]]></title>
    <url>%2F2018%2F04%2F23%2Fdiary20180423%2F</url>
    <content type="text"><![CDATA[15:37:43 违了小米，签了华为（北京）。 23:57:47 明后两天的上海之行，不知是什么新的风景。 0:03:05 今天与胡、伟达、浩一起玩了一个晚上。吃了花甲，去了网吧。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统实现学习]]></title>
    <url>%2F2018%2F04%2F22%2Fnote-os-create%2F</url>
    <content type="text"><![CDATA[操作系统启动流程： 主机接通电源 主机从磁盘加载bios。 bios把MBR（Main Bootrap Record，主引导记录）加载到0x7c00 实模式地址布局Intel8086有20条地址线，可以访问的内存空间数量有1MB，即220=1048576=1MB，十六进制为0x00000~0xFFFFF。 这1MB内存的布局如下： 汇编笔记每条汇编指令都位于某个地址，编译之后变成机器码或数据。 编译器给程序中各个符号分配的地址，就是各符号相对于文件开头的偏移量。 $$ 所在section起始地址 lablel:当前指令地址，用作jmp跳转的目的地 section: 对程序无影响，仅仅是让代码更易读。 例： 12section codemov ax,section.code.start 如果这是第一个section，第二行相当于mov ax,0x0。 vstart或org：虚拟地址偏移量。汇编代码的真实地址没有改变，但是代码中$、$$获取的地址都相对于原来加一个vstart。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180422]]></title>
    <url>%2F2018%2F04%2F22%2Fdiary20180422%2F</url>
    <content type="text"><![CDATA[12:20:10 昨天偶然看到Linus的自传《Just for fun》，从其中看到Linus是看《操作系统：设计与实现》这本教材写出的Linux。看了这本书，真是有醍醐灌顶的感觉。 19:28:50 这两天看战神的视频，纯黑又开始做了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180421]]></title>
    <url>%2F2018%2F04%2F21%2Fdiary20180421%2F</url>
    <content type="text"><![CDATA[13:18:24 收拾屋子、洗衣服等等明明很快就可以完成的事情，却往往耗上半天。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180420]]></title>
    <url>%2F2018%2F04%2F20%2Fdiary20180420%2F</url>
    <content type="text"><![CDATA[10:18:13 这两天发生了一连串事情。 19号收到华为签约通知 19号收到依图科技的面试通知 19号 成姐竟然要来长沙！原本要去车站接，但后来社里有人接。 20号 与鹏哥聊 20号 与基哥聊 13:55:04 订好了车票，酒店]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180419]]></title>
    <url>%2F2018%2F04%2F19%2Fdiary20180419%2F</url>
    <content type="text"><![CDATA[10:28:48 昨晚头痛睡的比较早。睡的挺好，起的略晚。 13:37:01 收到了华为的签约通知。 0:53:01 帮邱素欣做了道编程题。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180418]]></title>
    <url>%2F2018%2F04%2F18%2Fdiary20180418%2F</url>
    <content type="text"><![CDATA[22:19:42 今天中期检查，比想象的还水。刚刚与胡伟治看了狂暴巨兽，效果不错，剧情一般。 22:21:28 小学同学说有事找我，来了电话。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ucore Lab解答]]></title>
    <url>%2F2018%2F04%2F17%2Fnote-os-ucore%2F</url>
    <content type="text"><![CDATA[Lab 1 系统软件启动过程练习1在此练习中，大家需要通过静态分析代码来了解： 操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果) 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？ 特殊字符： $@ –代表目标文件(target) $^ –代表所有的依赖文件(components) $&lt; –代表第一个依赖文件(components中最左边的那个)。 结合答案作出脑图。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180417]]></title>
    <url>%2F2018%2F04%2F17%2Fdiary20180417%2F</url>
    <content type="text"><![CDATA[17:34:03 今天浪费了一大半时间，上午面试面了一小时，中午出门吃饭回来才发现没带钥匙，无法进门，结果陪胡去了蓝杰，还碰巧见到了辉哥，一起聊了很久。现在才回到家。 22:37:16 澎湖湾面临实习转正，心境与我当时大体相同，但他一定比我更有前途。我们的对话，保存下来。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180416]]></title>
    <url>%2F2018%2F04%2F16%2Fdiary20180416%2F</url>
    <content type="text"><![CDATA[10:33:08 下午老师开会。不需要去了，开心。 13:06:48 来到凯李。 22:25:37 跟张楠的交流，让我对世界充满向往。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《深入理解计算机系统》读书笔记]]></title>
    <url>%2F2018%2F04%2F15%2Fnote-reading-csapp%2F</url>
    <content type="text"><![CDATA[第一章 计算机系统漫游Q：编译系统（compilation system）是怎样构成的？一个C语言源文件hell.c是怎样转化为二进制文件的？（chapter 1.2）A： 四个阶段：预处理、编译、汇编、链接。 预处理阶段：预处理器（c preprocessor）根据#开头的命令，直接修改原始C程序。如直接将include的头文件插入到程序文本中。得到新的C程序，一般以.i作为文件名。 编译阶段：编译器（c compiler）将文本文件hello.i翻译为汇编程序hello.s。 汇编阶段：汇编器（Assembler）将hello.s翻译成机器语言指令，把这些指令打包为可重定位目标程序（relocatable Object program）格式，并将结果保存在目标文件hello.o中。 链接阶段：将hello.c程序中调用的函数从库中找出来，并合并到目标文件，最终成为可执行文件。 Q：字和字长是什么？（chapter 1.4.1）A： 在硬件组成中，总线贯穿其中，将信息在各个部件中传递，而具体传递的是定长（fixed-sized）的字节块（chunks of bytes），即字（words）。字中的字节数（字长，word size）是一个基本的系统参数。如果是4个字节则为32位，8个字节则为64位。 Q：CPU的基本运行流程是什么？（chapter 1.4.1.4）A： 循环以下操作：读取程序计数器（program counter，PC）指向的内存处的指令，解释其中的位，并执行指令所指定的几个简单的操作，再更新程序计数器，使其指向下一个指令。下一个指令不一定与刚刚执行的指令相邻。 所谓简单的操作是指： 加载（Load）：从主存中复制一个字节（byte）或者一个字（word）到寄存器，覆盖寄存器原来的内容。 存储（Store）：从寄存器复制一个字节或一个字的到主存的某个位置，覆盖原来的内容。 更新（Update）：把两个寄存器的内容复制到ALU，ALU对两个字做算数运算，并将结果放在一个寄存器中，覆盖寄存器原来的内容。 IO Read：从一个IO设备复制一个字节或一个字到一个寄存器中。 IO Write：从一个寄存器复制一个字节或一个字到一个IO设备中。 跳转（Jump）：从指令本身抽取一个字，并复制到程序计数器中，覆盖其原来的值。 Q：虚拟内存是什么，是怎样分布的？（chapter 1.7.3）A： 虚拟内存是一个抽象概念，它为每个进程提供一个假象，每个进程（process）看起来都在独占地使用整个主存。每个进程看到的内存都是一致的，称为“虚拟地址空间”。主要包括： 程序代码和数据（program code and data） 堆（heap） 共享库（shared libraries） 栈（stack） 内核虚拟内存（kernel virtual memory） 虚拟内存的基本思想：把一个进程的虚拟内存的内容存储在磁盘上，用主存作为磁盘的缓存。（？） Q：什么是阿姆达尔（amdahl）定律？A： 总体思想： 设系统执行某应用程序需要的时间是Told， 系统某部分所需时间与Told时间的比例为α，即需要Told · α的时间，这部分性能提升了k，则这部分所花费时间为Told · α / k。则优化性能后，系统整体花费时间为： Tnew = ( 1 - α ) · Told + ( α · Told / k ) = Told · [ ( 1 - α ) + α / k ] 那么加速系数 S 有： S = Told / Tnew= 1 / [ ( 1 - α ) + α / k ) ] 例如，系统中某个部分原本耗时比例为60%，（即α=0.6），如果加速比例为3（k = 3），我们可以获得总体加速比例为1.67。虽然我们对某个主要部分作出重大改进，但是系统整体加速明显小于这部分加速比。 这就是阿姆达尔定律的主要观点：想要显著加速整个系统，必须提升全系统相当大部分的速度。 第二章 信息的表示和处理Q：字节的格式是怎样的，为什么经常用十六进制表示？（chaper 2.1.1）A： 一个字节（byte）由八个位（bit）组成，在二进制表示法中，值域为 000000002~1111111110 即0~255。二进制表示法冗长，十进制表示法难以与二进制互相转换。十六进制刚好，值域为 0016~FF16。 Q：2n怎样转换为十六制？A： 对于x = 2n，如果想转换为二进制，只需写下1，跟上n个0。如 210 = 2110 = 102，102410 = 21010 = 0100 0000 00002。则十六进制明显为40016。 Q：字长（word size）有什么意义？（chapter 2.1.2）与字节（byte）是什么关系A： //本问题暂时搁置 字长（word size）是CPU的概念，表示CPU一次能并行处理的数据位数。 汉语 英语 含义（换算） 字 word 处理器处理的基本单位，也是虚拟地址的表示单位，每个虚拟地址都是一个word 字长 word size 一个word里含有的bit数量，即处理器ALU可同时处理的bit位数 字节 byte 8bit 对于字长为4的系统，每个虚拟地址（1个word）有4个byte，，所能表示的地址上限是232 bit = 4GB。 字长决定了指针数据的标准大小（nomainal size），而虚拟地址就是以字长的大小编码的，所以字长决定了虚拟地址的空间的大小。如字长为w位，那么虚拟地址范围为 0~2w-1。 对于字长为4的系统，每个虚拟地址有 4个byte，即32个bit，所能表示的地址上限是232 bit = 4GB。 而对于字长为8的系统，每个虚拟地址有8个byte，即64个bit，所能表示的地址上限是264 bit = 数据换算： 1GB = 210MB = 220KB = 230byte = 233bit 4GB = 22GB = 212MB = 222KB = 232byte = 235bit 字长=每个虚拟地址的字节（byte）数 = 一个word包含的byte数 Q：如何用位向量表示集合？（chapter 2.1.6）A： 以1的位置表示元素（从右向左）。如位向量a=[01101001]表示集合A={0,3,5,6}。 这样，或和与的操作可以直接用位向量实现。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180415]]></title>
    <url>%2F2018%2F04%2F15%2Fdiary20180415%2F</url>
    <content type="text"><![CDATA[13:13:19 分布式计算的程序运行情况不错，很开心。 13:13:33 终于感受到了虚拟桌面的作用！把需要长时间计算的程序放在某个桌面，再开个桌面干别的，清爽！ 23:44:03 每天早晨到面馆吃面，竟然每天自然而然地看了会新闻。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180414]]></title>
    <url>%2F2018%2F04%2F14%2Fdiary20180414%2F</url>
    <content type="text"><![CDATA[14:04:11 果然昨晚喝的太多，今天起晚了。重新写了PSO基本算法。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180413]]></title>
    <url>%2F2018%2F04%2F13%2Fdiary20180413%2F</url>
    <content type="text"><![CDATA[10:41:46 即将中期检查，需要调整下心态。不要着急，没有那么夸张。 0:27:51 今天蓝杰一游，再次感受到熟悉的心境。只要来到蓝杰，一定会感到智商不够用。见识到了常总的实力和经历。与胡姐谈心，竟然被说哭了。我胡看起来要报名了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180412]]></title>
    <url>%2F2018%2F04%2F12%2Fdiary20180412%2F</url>
    <content type="text"><![CDATA[10:04:54 今天起床比较早，洗了个澡，三方也到了。 13:10:04 大雨滂沱。持续学习WCF。 23:35:11]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180411]]></title>
    <url>%2F2018%2F04%2F11%2Fdiary20180411%2F</url>
    <content type="text"><![CDATA[12:47:15 昨晚被批评代码写的不好，连夜重构，元气大伤。 21:01:00 中午去库可，结果被热回来了。在家的效率并不低。WCF初步掌握。 22:21:53 刚刚发现日志数整100了 。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180410]]></title>
    <url>%2F2018%2F04%2F10%2Fdiary20180410%2F</url>
    <content type="text"><![CDATA[11:03:51 今天天气不错，适合游玩。拿到了牛客的衣服 。 18:40:57 与胡去了洋湖湿地公园。路上决定学操作系统。回来去步步高吃了冰。又吃了肉卷和凉皮。撑死我了。 22:07:37 如果用windows做分布式计算，最好还是用hadoop thrift]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java-nio-note]]></title>
    <url>%2F2018%2F04%2F09%2Fjava-nio-note%2F</url>
    <content type="text"><![CDATA[概览 用NIO API编写的应用，分别从服务端和客户端来看。 服务端框架：使用一个线程处理所有Channel。 创建Selector： 1Selector selector = Selector.open(); 创建server的channel： 1ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); 绑定本地接口，设置为非阻塞模式 1serverSocketChannel.socket().bind(new InetSocketAddress(listenPort)); 将selector注册到服务端channel，设置状态为“准备就绪” 1serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); 在（无限）循环的代码中，selector选择信道，返回已经就绪的信道数量。如果为0，应当重新选择。 1int keys = selector.select(TimeOut); 返回selector选中的信道集合，并进行遍历，对每个信道进行处理。 123Set&lt;SelectionKey&gt; set = selector.selectedKeys();while (keyIter.hasNext()) &#123; SelectionKey key = keyIter.next(); 当这批信道处理结束之后，移除处理过的键。 1keyIter.remove(); 链接处理过程对于每个客户端连接，都有其自己的属性：connectable，acceptable，readable，Writable，即连接就绪，接收就绪，读取就绪，写入就绪。事实上，在上述register方法中传入的最后一个参数就是服务端“感兴趣”的方面。 分别分发： 12345678910111213141516171819202122232425try &#123; if (key.isAcceptable()) &#123; System.out.println("acceptable"); //该方法在内部，会将interest由OP_ACCEPT改为OP_READ //如果不执行下面的语句，则会一直是accept状态（初始时设置为了accept），无法进入后面的两个if语句 //console一直打印上面的语句 protocol.handleAccept(key); &#125; if (key.isReadable()) &#123; // 从客户端读取数据 System.out.println("readable"); protocol.handleRead(key); &#125; if (key.isValid() &amp;&amp; key.isWritable()) &#123; //客户端连接一次后，N次连续进入该方法 //System.out.println("writable");//连续输出 protocol.handleWrite(key); &#125;&#125; catch (IOException ex) &#123; // 出现IO异常（如客户端断开连接）时移除处理过的键 keyIter.remove(); continue;&#125; 分别处理： 对于“接受就绪”的情况： 12345public void handleAccept(SelectionKey key) throws IOException &#123; SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept(); clientChannel.configureBlocking(false); clientChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)); &#125; 对于“读取就绪”的情况 1234567891011121314151617181920212223242526272829303132333435public void handleRead(SelectionKey key) throws IOException &#123; // 获得与客户端通信的信道 SocketChannel clientChannel = (SocketChannel) key.channel(); // 得到并清空缓冲区 ByteBuffer buffer = (ByteBuffer) key.attachment(); buffer.clear(); // 读取信息获得读取的字节数 long bytesRead = clientChannel.read(buffer); if (bytesRead == -1) &#123; // 没有读取到内容的情况 clientChannel.close(); &#125; else &#123; // 将缓冲区准备为数据传出状态 buffer.flip(); // 将字节转化为为UTF-16的字符串 String receivedString = Charset.forName("UTF-16").newDecoder().decode(buffer).toString(); // 控制台打印出来 System.out.println("接收到来自" + clientChannel.socket().getRemoteSocketAddress() + "的信息:" + receivedString); SimpleDateFormat format = new SimpleDateFormat("yyyy-mm-dd HH:mm:ss"); String f = format.format(new Date()); // 准备发送的文本 String sendString = "你好,客户端. @" + f + "，已经收到你的信息:" + receivedString; buffer = ByteBuffer.wrap(sendString.getBytes("UTF-16")); clientChannel.write(buffer); // 设置为下一次读取或是写入做准备 key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE); &#125; &#125;]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>nio</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180409]]></title>
    <url>%2F2018%2F04%2F09%2Fdiary20180409%2F</url>
    <content type="text"><![CDATA[10:39:38 来到凯李咖啡。这里10点半才开门 。 10:52:30 开始最终的复习！ 12:19:28 这是一种什么心理呢？因孤独而不快，却也排斥别人的靠近。 13:27:19 还是要分人的。跟学妹聊的很开心。 23:17:07 网易从20:00面到20:40，感觉还可以。至此，我的春招也告一段落了。最想去的网易，请给我个笑脸吧。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM性能优化总结]]></title>
    <url>%2F2018%2F04%2F08%2Fjava-jvm-optimization%2F</url>
    <content type="text"><![CDATA[jvm调优过程 定位问题。使用一些工具如jstack，jhat，jps，JMC，btrace 等工具，或者java自带的参数来查看Java进程的状态、是否在等待锁、进程的CPU和内存占用多少，GC状态如何，FULL GC是否频繁，内存是否泄露等。 解决问题。1.理解JVM的工作原理，通过运行参数来验证问题。 能力要求： 常用jvm参数 调优工具 GC原理 理解heap dump 常用工具用于jvm调优的工具可以分为 Java应用监控工具，包括 jconsole，jvisualvm JVM监控工具，包括 jps，`` 问题定位工具 分别对应官方文档的12，13，15部分。 Java应用监控工具jconsole以图形化界面监控Java应用的 堆内存趋势 线程数趋势 类加载数量 CPU占用率 如图： 参考官方文档 jvisualvm更加全面、直观地监控java应用的细节，分析内存、cpu和dump。 如图： JVM监控工具Jps 虚拟机进程信息查看工具功能：查看指定hotspot虚拟机的java进程，列出lvmid（本地虚拟机唯一ID），主类类名，main参数，jvm参数，jar名称等静态信息。内容比较简单。 参考官方jps文档以及官方教程。 jstat 虚拟机运行状态监控工具可以通过各种参数对JVM（对于某个lvmid）进行非常细致的监控。 监视类装载、卸载数量、总空间以及装载耗费时间 Loaded：加载的类的数量 Bytes：加载的空间（kB） Unloaded：卸载的类的数量 Bytes：卸载的空间（kB） Time：加载/卸载的总时间 例： PS C:\Users\libin&gt; jstat -class 31296 Loaded Bytes Unloaded Bytes Time 5883 12953.1 3 2.8 1.56 监视Java堆垃圾回收状况。单位为kB S0C：当前survivor0区的容量 S1C：当前survivor1区的容量 S0U：survivor0区使用量 S1U：survivor1区使用量 EC：当前Eden区容量 EU：Eden区使用量 OC：当前老年代容量 OU：老年代使用量 PS C:\Users\libin&gt; jstat -gc 31296 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 9216.0 10752.0 0.0 0.0 47616.0 26950.4 107520.0 6643.8 36560.0 30046.2 2560.0 2304.5 8 0.034 5 0.161 0.194 监视Java内存代数和空间容量（kB） NGCMN：年轻代初始化大小 NGCMX：年轻代最大容量 NGC：年轻代当前容量 S0C：survivor0的容量 S1C：survivor1的容量 EC：Eden的容量 OGCMN：老年代初始化大小 OGCMX：老年代最大容量 OGC：老年代当前新生成的容量 OC：老年代容量 MCMN：元数据元的初始化容量 MCMX：元数据区最大容量 MC：元数据区当前容量 CCSMN：压缩类空间最小容量 CCSMX：压缩类空间最大容量 CCSC：压缩类空间的容量 YGC：年轻代GC次数 FGC：full GC次数 PS C:\Users\libin&gt; jstat -gccapacity 31296 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC 62464.0 1000448.0 69120.0 9216.0 10752.0 47616.0 125952.0 2001920.0 107520.0 107520.0 0.0 1083392.0 36560.0 0.0 1048576.0 2560.0 8 5 垃圾回收数据统计 S0：survivor0区占用比例 S1：survivor1区占用比例 E：Eden区占用比例 O：老年代占用比例 M：元数据区占用比例 CCS：压缩类空间占用比例 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 FGC：full GC次数 FGCT：full GC消耗时间 GCT：垃圾回收总时间 PS C:\Users\libin&gt; jstat -gcutil 31296 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 56.60 6.18 82.18 90.02 8 0.034 5 0.161 0.194 在gcutil基础上增加了LGCC和GCC LGCC：最后垃圾回收的原因 GCC：当前垃圾回收的原因 PS C:\Users\libin&gt; jstat -gccause 31296 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT LGCC GCC 0.00 0.00 56.60 6.18 82.18 90.02 8 0.034 5 0.161 0.194 JvmtiEnv ForceGarbageCollection No GC 新生代行为统计 S0C：当前survivor0容量 S1C：当前survivor1容量 S0U：当前survivor0使用量 S1U：当前survivor1使用量 TT：持有次数限制 MTT：最大持有次数 DSS：期待的survivor大小 EC：当前Eden区空间容量 EU：Eden区空间使用量 YGC：年轻代GC次数 YGCT：年轻代GC消耗时间 PS C:\Users\libin&gt; jstat -gcnew 31296 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 9216.0 10752.0 0.0 0.0 9 15 10752.0 47616.0 26950.4 8 0.034 新生代容量统计 PS C:\Users\libin&gt; jstat -gcnewcapacity 31296 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 62464.0 1000448.0 69120.0 333312.0 9216.0 333312.0 10752.0 999424.0 47616.0 8 5 老年代和元数据区行为统计 PS C:\Users\libin&gt; jstat -gcold 31296 MC MU CCSC CCSU OC OU YGC FGC FGCT GCT 36560.0 30046.2 2560.0 2304.5 107520.0 6643.8 8 5 0.161 0.194 老年代大小统计 PS C:\Users\libin&gt; jstat -gcoldcapacity 31296 OGCMN OGCMX OGC OC YGC FGC FGCT GCT 125952.0 2001920.0 107520.0 107520.0 8 5 0.161 0.194 元数据区大小统计 MCMN：元数据区最小容量 MCMX：元数据区最大容量 MC：元数据区当前容量 CCSMN：压缩类空间最小容量 CCSMX：压缩类空间最大容量 YGC：年轻代垃圾回收次数 FGC：full GC次数 FGCT：full GC时间 GCT：垃圾回收总时间 PS C:\Users\libin&gt; jstat -gcmetacapacity 31296 MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC FGCT GCT 0.0 1083392.0 36560.0 0.0 1048576.0 2560.0 8 5 0.161 0.194 参考官方jstat教程 jms Java任务控制工具功能：作为一套图形化工具集合，用于配置、监控和诊断。 问题定位工具（heap dump 与 thread dump）jcmd 本地java应用信息查看工具功能：这是一个多功能工具，可以查看线程信息、导出堆信息等，可以代替jmap。 jmap功能：分析java堆。可以生成Java堆转储快照，并对其分析。 jstack功能，分析线程，生成Java线程快照。 典型问题及处理 流程运行如代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; private static Object object1 = new int[1]; private static Object object2 = new int[2]; public class Thread1 extends Thread &#123; @Override public void run() &#123; System.out.println("thread1 start"); synchronized (object1) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread 1 get lock 1 need lock 2"); synchronized (object2) &#123; &#125; &#125; System.out.println("thread1 end"); &#125; &#125; public class Thread2 extends Thread&#123; @Override public void run() &#123; System.out.println("thread2 start"); synchronized (object2) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread 2 get lock 2 need lock 1"); synchronized (object1) &#123; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Thread1 thread1 = new Test().new Thread1(); Thread2 thread2 = new Test().new Thread2(); thread1.start(); thread2.start(); &#125;&#125; 运行结果： 1234thread2 startthread1 startthread 2 get lock 2 need lock 1thread 1 get lock 1 need lock 2 两个线程处于死锁状态，相互需要对方持有的锁。 解决方案：使用jps或jcmd查看线程id，再使用jstack &gt; dumpthread。 通过jcmd得知线程id是29248 123D:\CODE\ideaProject\untitled27&gt;jcmd29248 Test8136 sun.tools.jcmd.JCmd 通过jstack发现死锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119D:\CODE\ideaProject\untitled27&gt;jstack 292482018-04-08 21:12:29Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.161-b12 mixed mode):&quot;DestroyJavaVM&quot; #14 prio=5 os_prio=0 tid=0x0000000005233800 nid=0x77f4 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Thread-1&quot; #13 prio=5 os_prio=0 tid=0x000000001e547800 nid=0x9440 waiting for monitor entry [0x000000001f2bf000] java.lang.Thread.State: BLOCKED (on object monitor) at Test$Thread2.run(Test.java:36) - waiting to lock &lt;0x00000007830b34a8&gt; (a [I) - locked &lt;0x00000007830b34c0&gt; (a [I)&quot;Thread-0&quot; #12 prio=5 os_prio=0 tid=0x000000001e546800 nid=0x75c waiting for monitor entry [0x000000001f1bf000] java.lang.Thread.State: BLOCKED (on object monitor) at Test$Thread1.run(Test.java:19) - waiting to lock &lt;0x00000007830b34c0&gt; (a [I) - locked &lt;0x00000007830b34a8&gt; (a [I)&quot;Service Thread&quot; #11 daemon prio=9 os_prio=0 tid=0x000000001e3f2800 nid=0x6abc runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C1 CompilerThread3&quot; #10 daemon prio=9 os_prio=2 tid=0x000000001e3a7800 nid=0x7ff4 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread2&quot; #9 daemon prio=9 os_prio=2 tid=0x000000001e3a2000 nid=0x4f9c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread1&quot; #8 daemon prio=9 os_prio=2 tid=0x000000001e390800 nid=0x8f8c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #7 daemon prio=9 os_prio=2 tid=0x000000001e38e000 nid=0x210c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Monitor Ctrl-Break&quot; #6 daemon prio=5 os_prio=0 tid=0x000000001e368000 nid=0x8e10 runnable [0x000000001eabe000] java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) - locked &lt;0x0000000783118ea0&gt; (a java.io.InputStreamReader) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) - locked &lt;0x0000000783118ea0&gt; (a java.io.InputStreamReader) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x000000001e2fc000 nid=0x7fcc waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x000000001e350000 nid=0x64c0 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x000000001c3e3800 nid=0x82e0 in Object.wait() [0x000000001e7bf000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x0000000782f08ec0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) - locked &lt;0x0000000782f08ec0&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x000000001c3dc800 nid=0x46c8 in Object.wait() [0x000000001e2bf000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x0000000782f06b68&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x0000000782f06b68&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Thread&quot; os_prio=2 tid=0x000000001c3d8800 nid=0x8c34 runnable&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000005249000 nid=0x8cf4 runnable&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x000000000524a800 nid=0x87f0 runnable&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000524c000 nid=0x7820 runnable&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000524d800 nid=0x760 runnable&quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x000000000524f800 nid=0x2dc4 runnable&quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x0000000005252000 nid=0x722c runnable&quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x0000000005255000 nid=0x92d4 runnable&quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x0000000005256000 nid=0x6a30 runnable&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x000000001e4e6800 nid=0x4854 waiting on conditionJNI global references: 30Found one Java-level deadlock:=============================&quot;Thread-1&quot;: waiting to lock monitor 0x000000001c3e2c78 (object 0x00000007830b34a8, a [I), which is held by &quot;Thread-0&quot;&quot;Thread-0&quot;: waiting to lock monitor 0x000000001c3e03e8 (object 0x00000007830b34c0, a [I), which is held by &quot;Thread-1&quot;Java stack information for the threads listed above:===================================================&quot;Thread-1&quot;: at Test$Thread2.run(Test.java:36) - waiting to lock &lt;0x00000007830b34a8&gt; (a [I) - locked &lt;0x00000007830b34c0&gt; (a [I)&quot;Thread-0&quot;: at Test$Thread1.run(Test.java:19) - waiting to lock &lt;0x00000007830b34c0&gt; (a [I) - locked &lt;0x00000007830b34a8&gt; (a [I)Found 1 deadlock. 易看出两个线程处于死锁状态。而且已经标识出代码的位置：Test.java的36行和19行，即两个synchornized块。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180408]]></title>
    <url>%2F2018%2F04%2F08%2Fdiary20180408%2F</url>
    <content type="text"><![CDATA[14:24:26 来到库克咖啡。收到网易视频面试的邮件，明晚7点半面试。也许是最后一次面试了，通过与否，我的日复一日的低效学习也即将告一段落。 22:36:16 9点左右与胡去江边看了一下，回家。这两天嗓子痛，买了穿心莲内脂的药。滴丸，应该是倒嘴里用水送下去。然而我竟然用水重开了。趁完全溶解之前我试图一起喝下去，结果把水喝了药剩下了，苦！索性把它们用水重开。 22:38:48 现在我即将咽下这黄色的苦水。 22:40:05 咽下去了。苦不堪言，虽然没有到完全无法忍受的程度。难受的是身边没有凉水，苦味没法消除！ 22:53:13 苦味渐渐消除 。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180407]]></title>
    <url>%2F2018%2F04%2F07%2Fdiary20180407%2F</url>
    <content type="text"><![CDATA[12:56:12 买了一些水果 。 23:33:43 白天在家宅了一天。晚上与胡、浩去吃了大斌家。浩给我拍了张照片。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dev-blogmanager]]></title>
    <url>%2F2018%2F04%2F07%2Fdev-blogmanager%2F</url>
    <content type="text"><![CDATA[图片压缩 图片尺寸修正]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>开发记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180406]]></title>
    <url>%2F2018%2F04%2F06%2Fdiary20180406%2F</url>
    <content type="text"><![CDATA[14:05:10 今天起晚了。原因是杨康楠来长沙，手机坏了，我把我的红米note4借给他，格式化了，闹钟没响。 14:44:04 当某件事发生的频率被主动或被动地提升至每天一次或每天多次，就有必要写个软件优化下了。 22:56:03 今天下午与楠，浩玩的很开心。下午吃了虾吃虾涮，打了一局台球。晚上到麓南青年街喝了奶茶。我楠打了美团打车滴滴回河东，我送许浩回后街。 0:46:11 想到了一种新的分类方法！是否与人有关？比如，图片脱离了人类仍然是图片，而“自拍”则无法与人分离！或者用更简单直观的方式：用“它是一种…，可以用来…，与人有/无关。”造句。造出来，则得结果。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180405]]></title>
    <url>%2F2018%2F04%2F05%2Fdiary20180405%2F</url>
    <content type="text"><![CDATA[12:25:34 大幅修改了博客样式。 20:58:08 清明雨密，在家呆了一天。 0:01:57 终于把事务的隔离级别的细节搞懂了。 0:21:30 想做个“One Big Thing”的app，格式化记录每一天最重要的事情。 0:24:55 嗯。。或者叫做Moment。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180404]]></title>
    <url>%2F2018%2F04%2F04%2Fdiary20180404%2F</url>
    <content type="text"><![CDATA[13:04:02 来到库可咖啡。日记的格式还不够格式化。 15:32:36 收到华为的面试通过短信，十分开心。 23:58:39 尝试增加“实验”性质、以exp开头的博客文章。 0:25:23 晚上与许浩在校园逛了逛。陪他吃了转转锅。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180403]]></title>
    <url>%2F2018%2F04%2F03%2Fdiary20180403%2F</url>
    <content type="text"><![CDATA[上午参加了华为面试。一个技术大佬，一个管理大佬。需要进步的还有很多。尝试发现技术的乐趣吧。 下午跟胡到了西边华为的售后店。 21:05:58 还有三个月就毕业了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180402]]></title>
    <url>%2F2018%2F04%2F02%2Fdiary20180402%2F</url>
    <content type="text"><![CDATA[10:37:36 携小本来到凯李咖啡。 11:31:18 feel。 22:08:30 对职业发展的困惑和不安，其实换个角度思考会好很多：你希望你十年之后是什么样子？奔着那个方向努力吧。 今天毕设检查，没什么值得记录的。下午与胡买了水果喝啤酒吃炸鸡去网吧。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql官方性能优化笔记]]></title>
    <url>%2F2018%2F04%2F01%2Fnote-mysql-optimization-official%2F</url>
    <content type="text"><![CDATA[整理自mysql官方文档 概述数据库的性能优化主要有三个方面： 数据库级别的优化 硬件级别的优化 平衡可移植性和性能 SQL语句优化SELECT语句优化WHERE字句的优化]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql性能优化相关命令]]></title>
    <url>%2F2018%2F04%2F01%2Fnote-mysql-performance-command%2F</url>
    <content type="text"><![CDATA[explain命令（参考：https://segmentfault.com/a/1190000008131735） 对于脚本： 1234567891011121314151617181920CREATE TABLE `order_info` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `user_id` BIGINT(20) DEFAULT NULL, `product_name` VARCHAR(50) NOT NULL DEFAULT '', `productor` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`), KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)) ENGINE = InnoDB DEFAULT CHARSET = utf8INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE'); 做explain查询有： 1explain select * from user_info where id = 2\G 结果： 1234567891011121314*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: constpossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 解释： id：每个select都会自动分配一个唯一标识符。 select_type:SELECT的类型。 SIMPLE：表示此查询不包含UNION查询或子查询 PRIMARY：表示此查询是最外层的查询。 UNION, 表示此查询是 UNION 的第二或随后的查询 DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询 UNION RESULT, UNION 的结果 SUBQUERY, 子查询中的第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. table：查询涉及的表 partitions: 匹配的分区 type: join 类型，比较重要 system：表中只有一条数据 针对主键或唯一索引的等值查询扫描，最多只返回一行数据，速度非常快，因为仅仅读取一次即可。使用主键索引的查询就是const类型的。 eq_ref：此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如: 12345678910111213141516171819202122232425262728mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: indexpossible_keys: user_product_detail_index key: user_product_detail_index key_len: 314 ref: NULL rows: 9 filtered: 100.00 Extra: Using where; Using index*************************** 2. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: eq_refpossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: test.order_info.user_id rows: 1 filtered: 100.00 Extra: NULL2 rows in set, 1 warning (0.00 sec) ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. 例如 12345678910111213141516171819202122232425262728mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: constpossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL*************************** 2. row *************************** id: 1 select_type: SIMPLE table: order_info partitions: NULL type: refpossible_keys: user_product_detail_index key: user_product_detail_index key_len: 9 ref: const rows: 1 filtered: 100.00 Extra: Using index2 rows in set, 1 warning (0.01 sec) range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.例如 1234567891011121314151617mysql&gt; EXPLAIN SELECT * -&gt; FROM user_info -&gt; WHERE id BETWEEN 2 AND 8 \G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: rangepossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: NULL rows: 7 filtered: 100.00 Extra: Using where1 row in set, 1 warning (0.00 sec) index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.例如： 123456789101112131415mysql&gt; EXPLAIN SELECT name FROM user_info \G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: indexpossible_keys: NULL key: name_index key_len: 152 ref: NULL rows: 10 filtered: 100.00 Extra: Using index1 row in set, 1 warning (0.00 sec) ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免. 下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的. 123456789101112131415mysql&gt; EXPLAIN SELECT age FROM user_info WHERE age = 20 \G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 10 filtered: 10.00 Extra: Using where1 row in set, 1 warning (0.00 sec) possible_keys: 此次查询中能够用到的索引。但是不表示真正使用到。 key: 此次查询中确切使用到的索引. key_len：表示查询优化器使用量索引的字节数。 ref: 哪个字段或常数与 key 一起被使用 rows: 显示此查询一共扫描了多少行. 这个是一个估计值. filtered: 表示此查询条件所过滤的数据的百分比 extra: 额外的信息 type的比较通常来说, 不同的 type 类型的性能关系如下: ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快. 后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180401]]></title>
    <url>%2F2018%2F04%2F01%2Fdiary20180401%2F</url>
    <content type="text"><![CDATA[14:07:41 今天去了岳麓峰会，逛了一圈回来了。没什么意思。泰坤之后确实会起的很晚。腰酸背痛倒是没有那么夸张了。 21:09:43 泰坤归来，疲劳度越来越轻，时间也越来越快了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180331]]></title>
    <url>%2F2018%2F03%2F31%2Fdiary20180331%2F</url>
    <content type="text"><![CDATA[22:39:49 下午跟胡去了新校，到桃子湖转了转，那地方是真大呀。晚上去了泰坤，爽。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git相关记录]]></title>
    <url>%2F2018%2F03%2F30%2Fnote-git%2F</url>
    <content type="text"><![CDATA[安装之后的设置设置用户名12git config --global user.name &quot;libin&quot;git config --global user.email libinworkspace@qq.com 添加ssh key1ssh-keygen 加快clone1. 修改hosts文件 hosts文件目录：C:\Windows\System32\drivers\etc 分别 ping global-ssl.fastly.net 和 ping github.com ,分别获取ip，添加到hosts文件中，如下： 123456...# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost151.101.41.194 github.global.ssl.fastly.net192.30.253.112 github.com 刷新dns：ipconfig /flushdns 2. 修改缓冲区 git config --global http.postBuffer 524288000 避免文件名过长的error1git config --global core.longpaths true]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180330]]></title>
    <url>%2F2018%2F03%2F30%2Fdiary20180330%2F</url>
    <content type="text"><![CDATA[22:47:44 今天是写日记最晚的一天。这三天做PSO程序都比较认真。今天突然发现github或者码云真是分享markdown文档的最佳地点！但是github的话加载markdown中的图片可能有点问题。所以（终于）开始学（复习）起git了。 补记 今天下午与胡，许浩，违达去了小米之家，没多久便出，看了头号玩家电影，非常爽快。返程，去家润多吃了焖锅。回来笔了好未来。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180329]]></title>
    <url>%2F2018%2F03%2F29%2Fdiary20180329%2F</url>
    <content type="text"><![CDATA[11:59:06 程序遇到坑。由于ip需要在开始之前设置且无法改变，昨晚运行的时候我接了网线，用的是有线的ip，我却运行过程中插拔网线，导致ip变更，今早看到的结果不知是什么时候的结果。只好重新启动程序，增加了一些日志，借助excel分析一下数据。 12:48:07 feel。 23:40:10 把课外研学的学分的事情解决。 23:40:56 也许再难访问空间了。好事，好事。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java集合框架概述]]></title>
    <url>%2F2018%2F03%2F28%2Fnote-java-collection%2F</url>
    <content type="text"><![CDATA[综述 所有集合类位于java.util包下。集合类主要由两个接口派生而出，Collection和Map，它们描述了基本的功能,如size(),contains(),add(),remove()等。Map接口提供了以Collection查看数据的视角。 Collection的子接口有三类，List，Set，Queue。 List是有序集合，维护顺序，元素允许重复 Set是无序集合，元素不可以重复，访问只能通过本身来访问 Map是key-value集合，访问时只能根据key来访问value。 Q：jdk中队列时怎样的？在Queue接口中定义了队列的基本方法： add，offer 都是向队列里添加元素。如果队列满了，add抛出unchecked异常，offer后者返回false。 remove，poll 都是从队列中删除第一个元素，remove在空集合调用时抛出异常，poll返回null。 element，peek 都是在队列的头部查询元素。在队列为空时，element抛出异常，peek返回null。 在jdk中，队列主要分两组：实现阻塞队列接口的，和没有实现阻塞队列接口的。 阻塞队列接口：BlockingQueue 参考：https://www.cnblogs.com/xiaoxi/p/6089984.html]]></content>
      <categories>
        <category>技·术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180328]]></title>
    <url>%2F2018%2F03%2F28%2Fdiary20180328%2F</url>
    <content type="text"><![CDATA[12:56:20 feel。来到凯李咖啡。学长给的程序可以运行了，但是感觉实在是太不面向对象了。。。不过不打算重写一遍，我只完成我自己的工作。 20:41:41 下午辉哥请我喝了咖啡，晚上又请我吃了顿大馅饺子。 辉哥可能活成了我想要的样子。退学，销售，对产品的想法，对人生的态度，对他人眼光的态度，我几次尝试质疑，发现他的逻辑是自洽的，是不容易攻破的。从弘道书店走出来，我对他的心态从质疑和担心，转变成了尊重和期待。 在书店坐下时，我们几乎没有话题；一旦聊起对未来的想法、对产品的想法等，辉哥滔滔不绝。直到讨论起机器，讨论起AI，我才在应用和原理上有些谈资。在本部荷花池附近的小园，我一时兴起说我现场给你展示下编程吧。结果由于老久没动tomcat，搞了半天才做了个最基础的。 晚上又被请，感觉很不好意思。辉哥不管前路如何，他的自信和稳重，都非常值得我学习。 22:25:51 历经千辛万苦，终于把电脑重装好了。 22:26:04 今天B站上市了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180327]]></title>
    <url>%2F2018%2F03%2F27%2Fdiary20180327%2F</url>
    <content type="text"><![CDATA[17:51:21 在库可咖啡。今天看了小米发布会全程，又有了“卧槽”的感觉。真棒。 19:45:25 把分布式的程序初步运行了一下，每个粒子的要运算竟然几乎需要一分钟，没想到这么夸张。。果然分布式真的是非常必要的。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180326]]></title>
    <url>%2F2018%2F03%2F26%2Fdiary20180326%2F</url>
    <content type="text"><![CDATA[11:11:22 来到凯李咖啡。看看今天下午能汇报出什么。 11:48:12 发现经过前几天面百度时候的复习后，思路再次清晰很多。 17:01:33 来到库克。取了胡的毛衣。 19:45:36 即将把Aspen安装完毕。下午检查毕设的时候，本来十分紧张，这周全准备面试了，毕设一点都没动。结果我刚要说话就被老师给憋回来了，说了一堆，我练练说是。最终，我在办公室是一个字没说。光环附体。 19:50:00 计划：既然面试、工作、头脑风暴、开会的时候经常用到白板，为何不自己经常使用白板？计划买个白板立在床边，想问题时边画边讲，肯定理解的更好。顺便练习下演讲能力。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180325]]></title>
    <url>%2F2018%2F03%2F25%2Fdiary20180325%2F</url>
    <content type="text"><![CDATA[14:07:41 把阿朱给孩子起名的过程记录一下。 16:07:38 与胡来到西畔咖啡。这氛围过分了。。。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180324]]></title>
    <url>%2F2018%2F03%2F24%2Fdiary20180324%2F</url>
    <content type="text"><![CDATA[14:46:13 今天估计全天下雨。无法出门，不太开心。 17:42:58 最近尤其开心的是，之前很多看不懂的技术书，现在可以看得很顺畅了。 21:29:54 跟白翛譞微信聊了66分钟，挑电脑。唉，终于知道女生为什么逛街能逛一下午了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180323]]></title>
    <url>%2F2018%2F03%2F23%2Fdiary20180323%2F</url>
    <content type="text"><![CDATA[12:35:41 来到库克咖啡。今天喝柠七，不喝咖啡了。 13:43:36 写了个链表的快速排序，算上测试用例和空行总共约100行代码，写的很顺利，除了有个循环的变量忘了自减，基本上是一次成功。看来是自己把自己给吓住了，没什么难的。 16:52:28 需要总结一下学习方向。 尝试想想自己去面试世界上待遇最优厚，同时也是要求最高的的公司，我应该具备怎样的素质，简历上应该有哪些特质？ 个人实现的开源软件 强劲的算法实力 对专业方向任何面试问题的深入理解]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概念学习笔记]]></title>
    <url>%2F2018%2F03%2F22%2Fnote-db-common%2F</url>
    <content type="text"><![CDATA[在文件系统中存储组织信息的弊端？ 数据冗余和不一致。不同文件的结构不同，相同信息可能重复存储，导致存储和访问开销增大，导致数据不一致性——同一数据的不同副本不一致。例如，一个人在的姓名在城镇更新了，而没有在市区系统更新。 数据访问困难。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180322]]></title>
    <url>%2F2018%2F03%2F22%2Fdiary20180322%2F</url>
    <content type="text"><![CDATA[14:48:21 网络即毒药。最好的学习地方永远不是室内。 18:07:51 好消息，库克咖啡每天的营业时间延长到了9点半。也就是说每天有将近12个小时的时间。 0:49:02 竟然找到了八年前剪辑的火影游戏视频！泪目。。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习方法总结]]></title>
    <url>%2F2018%2F03%2F21%2Fthought-study-review%2F</url>
    <content type="text"><![CDATA[2018年6月27日面向接口编程？ 2018年6月19日在平常的日子里，更重要的应当是基本功。如何将基本功学的扎实？ 框架图示（一图胜千言！） 详细解释 优劣分析 2018年6月12日目前遇到一个问题，对于某个框架，放置时间一长，就不容易再拿起来。 一图胜千言，一个图片说明是非常有必要的。思维导图是真的必需品。对于任何一个框架，需要记住： 声明周期 架构体系 使用细节 接口是什么？接口描述的就是方法论。对应接口和接口文档，应当能作出较为生动易记的ppt。 应当注意到，在了解普遍存在的底层需求之前，去阅读相关文档是费力的。应当多阅读关于“设计”,“原理”的书籍。 2018年6月11日总结下学习方向。 持久学习：数据结构与算法 本职工作：spring系列，linux，jvm，sql 未来工作：操作系统，C/C++，计算机网络，分布式开发，大数据，机器学习 2018年3月21日临睡前有必要把今天的感受记录下来。 从接到百度面试通知开始，心情的转变是没有预料到的，却也在情理之中。没有实战的检验，没有面试官的逼问，总会觉得自己什么都会；这让我想起了衡中每次考前的复习，总是有种迷之自信。在考验来临的三个小时之前，心态会一直不错，而随着检验时间愈发接近，我竟会莫名其妙的懊悔、自我怀疑，甚至开始重新考虑人生方向？再到检验前10分钟，才有了实战前应有的心态，爱咋咋地。一切结束后，则会像健身完之后那般舒爽，倍感轻松。 那其中两个小时的心态是宝贵的，脑海里不断回响着一种声音，“你应该再夯实基础！你应该把教材啃透！你应该专门精通一个方向！你应该做好万全的准备！你应该….！”你应该，你应该。每当交付工作、面试求职，总想让自己变得完美无缺。而倘若平日过于松散，会让面试前的心情变得更加糟糕。 不管最终确定到哪里工作，CS专业基础和更佳的学习方法（——或者说记忆方法？）都是应当再度优化的方面。 就这两天的面试感受，对于记忆方法，应当进行进一步归纳。 首先，对于HashMap的总结方法是值得借鉴的。把HashMap分成两个部分来分析，先分析Map，再分析Hash。Map在Java中的角色是什么，数据结构是怎样的；Hash是什么，在计算机科学领域的概念是什么；其次从宏观分析Hash的目的和步骤（转化、压缩），再次分析Hash在HashMap内部的实现，各种对象如何转换为散列码，如何压缩为索引值；为什么要多一步高位运算。接下来多线程方面进行引申（即实际中常出现的问题），从源码的角度分析ConcurrentHashMap如何解决了多线程问题。 事实上简单来说，最佳的叙述思路/记忆思路，确实可以用小黄鸭记忆法来辅助。因为当我的思路是为一个不懂技术的人叙述技术原理时，我会自动按照背景——需求——宏观解决方案——解决方案细节——子方案——拓展问题的组织形式进行学习和记忆。 今天觉得，days review——自小米实习结束之后，我在湘浦旅馆不分昼夜地度过了几天，顿感时光飞逝，遂觉应当建立博客，以实时反思自己的自律方式——是十分必要，实践结果尚佳的。延长主观寿命的方法之一就是早起。当看到清晨的太阳，所有的困倦都会消失，而会对今天的时间充满信心。]]></content>
      <categories>
        <category>感·想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql概念汇总]]></title>
    <url>%2F2018%2F03%2F21%2Fnote-mysql-common%2F</url>
    <content type="text"><![CDATA[Q：数据库事务正确执行的四个基本要素（ACID）是什么？A： ACID对应的含义： A Atomicity 原子性C Consistency 一致性I Isolation 隔离性D Durability 持久性 Q：隔离级别有什么？不考虑隔离级别的问题： 脏读：在一个事务处理过程读取了另一个未提交的事务中的数据。 不可重复读/幻读：读取了另一条已经提交的事务，前者在于update和delete，后者在于insert 可重复读： 四中隔离级别： 串行化 可重复读（默认） 读已提交 读未提交 具体解释： 没有锁：两个事务同时写数据，其中一个被另一个覆盖，导致数据丢失。 读取未提交：写时加上排它锁，直到事务结束；读取时不加锁。读取到其他事务的数据，而其他事务数据回滚，则读取到脏数据。 读取已提交：写时加上排它锁，直到事务结束；读取读取完毕之后立刻释放共享锁。每次事务中重复读取某一数据，如果读取过程中其他事务对此数据修改了，则两次读取的数据不同，即不可重复读。 可重复读：写时加上排他锁，直到事务结束；读取时加上共享锁，直到事务结束。可避免重复读的问题。但是批量修改某相同值的数据时，其他事务增加了相同值的数据，则验证时发现存在未修改的数据，即幻读。 可串行化。串行执行事务，避免了以上问题。 Q：数据库范式？A： 1NF：列不能拆分为其他几列，是基本要求。缺点：数据冗余过大。 2NF：首先1NF；1. 必须有主键 2.没有包含在主键中的列必须完全依赖于主键，而不能依赖于主键的一部分。 3NF：首选NF；1. 不能存在传递依赖。 Q：sql优化？A： 只返回需要的数据。 忌 SELECT * 尽可能写WHERE 适当建立索引 避免全表扫描： 左模糊查询’%…’ OR使用不当，两边必须都有索引 WHERE子句对字段进行表达式操作 参考： https://www.cnblogs.com/wmbg/p/6800354.html]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180321]]></title>
    <url>%2F2018%2F03%2F21%2Fdiary20180321%2F</url>
    <content type="text"><![CDATA[9:46:22 来到库克咖啡。本以为9点开门，9点整到了，来回转了很久才开。 12:26:14 此刻的心情非常珍贵！考验来临时，退缩的心情会越来越重；而迎接挑战才是重生的契机！ 16:10:51 百度二面完毕！效率是真高啊。。。 0:27:24 今天网络终于恢复了。 1:24:37 与朱老哥聊了一会。感慨了一些。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[note-designpattern]]></title>
    <url>%2F2018%2F03%2F20%2Fnote-design-patterns%2F</url>
    <content type="text"><![CDATA[生产者消费者模型参考： https://www.jianshu.com/p/77770eafeae4 https://www.cnblogs.com/chentingk/p/6497107.html 门面模式门面模式（Facade Pattern，也称外观模式），是指提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP学习笔记]]></title>
    <url>%2F2018%2F03%2F20%2Fnote-network-tcpip%2F</url>
    <content type="text"><![CDATA[Q：简述OSI七层模型？A： 如下表： 分层 代表协议 应用层 HTTP，FTP 表示层 JPG，MPEG，HTML 会话层 SQL，ASP，JSP 传输层 TCP，UDP 网络层 IP，ICMP 数据链路层 802.2 物理层 IEEE 754（浮点数） Q：三次挥手的过程？ 客户端-&gt;服务器 SYN=x 服务器-&gt;客户端 ACK=x+1,SYN=y 客户端-&gt;服务器 ACK=y+1 Q：四次挥手的过程？A： 非常对称的FIN-ACK。 客户端-&gt;服务器 FIN 服务器-&gt;客户端 ACK 服务器-&gt;客户端 FIN 客户端-&gt;服务器 ACK Q：简述TCP与UDP的区别？A： 可靠性： TCP提供面向连接，保证数据正确；UDP非面向连接、不可靠，数据不一定正确。 侧重点： TCP注重数据安全，UDP注重速度，但安全性一般。 流与数据报： TCP是基于流的，具有缓存机制。UDP基于数据报，接收端必须用与发送端相同的次数读完。 参考： https://www.cnblogs.com/lca1826/p/6601327.html https://www.linuxidc.com/Linux/2014-11/109545.htm]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180320]]></title>
    <url>%2F2018%2F03%2F20%2Fdiary20180320%2F</url>
    <content type="text"><![CDATA[14:41:18 在凯李咖啡。果然接到面试通知才是效率飞涨的时候。 22:45:20 今天简直是过的飞快。下午在凯李咖啡疯狂复习了很多。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议相关学习笔记]]></title>
    <url>%2F2018%2F03%2F20%2Fnote-network-http%2F</url>
    <content type="text"><![CDATA[Q：URI与URL的区别是什么？后者是前者的主要表现形式。 URI：Uniform Resource Identifier，统一资源标识符 URL：Uniform Resoure Locator，统一资源定位符 URN：Uniform Resource Name，统一资源名称 URL = scheme + address + resource scheme：方案，说明协议类型，如HTTP协议，FTP协议 addres：地址，如www.test.com resource：某个资源，如 /test/test.doc Q：常见状态码？ 状态码 描述 中文描述 详细描述 200 OK 正确返回 301 Moved Permanently 永久转移 浏览器收到此状态码会自动跳转到新的地址。搜索引擎只会保存新的地址 302 Temporarily Moved 临时转移 与301相同，但搜索引擎会保存旧的网址。 305 Use Proxy 使用代理 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 Temporary Redirect 临时重定向 与301类似。大家都把301和302自动GET到新的URL，此状态码将将此合法化。 400 Bad Request 错误请求 服务器不理解语法 404 没有找到资源 500 Internal Server Error 内部错误 如无法识别请求方法 502 Bad GateWay 错误网关 服务器作为网关或代理，从上游服务器收到无效响应 504 GateWay Timeout 网关超时 服务器作为网关或代理，没有及时从上游收到请求 Q：HTTP协议的格式是什么样的？A： HTTP报文有三个部分,是由行分隔的ACSII文本。需要分请求报文和响应报文来讲。 1. HTTP请求报文 请求行(request line) 首部(header) 主体(body) 格式： 示例： 1.1 请求行作用： 向服务器说明 要做些什么。 请求行 = 请求方法 + URL + 协议版本 请求方法： GET，HEAD，PUT，TRACE，DELETE等 协议版本： HTTP/主版本号.次版本号 如 HTTP/1.0 1.2 请求头作用： 以键值对的形式添加一些附加信息，如ip，端口号，编码等 常见请求头： 请求头 说明 Host 接受请求的服务器地址，可以是IP:端口号，也可以是域名 User-Agent 发送请求的应用程序名称 Connection 指定与连接相关的属性，如Connection:Keep-Alive Accept-Charset 通知服务端可以发送的编码格式 Accept-Encoding 通知服务端可以发送的数据压缩格式 Accept-Language 通知服务端可以发送的语言 1.3 请求正文可选部分。GET请求就没有正文。 2. HTTP响应报文响应报文 = 状态行 + 响应头 + 响应正文 2.1 状态行状态行 = 协议版本 + 状态码 + 状态码描述 2.2 响应头作用： 以键值对的形式为响应报文添加一些附加信息，如响应正文的类型，是图片还是字符串，响应正文的长度，编码等 常见响应头： 响应头 说明 Server 服务器应用程序软件的名称和版本 Content-Type 响应正文的类型（是图片还是二进制字符串） Content-Length 响应正文长度 Content-Charset 响应正文使用的编码 Content-Encoding 响应正文使用的数据压缩格式 Content-Language 响应正文使用的语言 2.4 响应正文包含服务器返回的内容个，如HTML数据 Q：HTTP与HTTPS 的区别于与联系？HTTP外面套一层SSL。 区别： HTTPS需要CA整数，需要交费。 HTTPS并非明文传输，HTTP明文传输。 Q：HTTP为什么不安全？HTTPS为什么安全？A： HTTP是明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改。 HTTPS的安全原理： 首先了解对称加密。双方都用同样的密钥加解密。事先无法商讨出用哪个密钥。如果事先商讨出用的密钥，后续无法更改，一方更改，另一方无法获知。且一旦一方泄露，整个通信被破解。 非对称加密，可以实现单项的安全。甲生成公私钥，公开公钥，乙用其公钥加密数据，发送给甲，甲用没有公开的私钥解密。这样乙-&gt;甲的通信就十分安全。 在HTTPS握手过程中，每次非对称加密用于生成一个对称密文，即每次都会变化的对称密文。 Q：在客户端对HTTPS抓包，得到的是密文还是明文？A： wireshark 抓取的https协议的包是密文,firebug抓到的https的包是明文。 firebug是firefox内部的东西，所以firefox看到的内容它也看得到；wireshark是装了个网卡劫持驱动(pcap)，拿到的是途径网卡的已经被包装成TLS隧道后的内容. Q：简要说明SSL握手？前提： 服务器拥有CA证书（包含公钥和私钥） 客户运行SSL client服务 客户端-&gt;服务器 client_hello （443端口）（包含协议信息，和随机数1) 服务器-&gt;客户端 server_hello （包含证书信息,即公钥，和随机数2） 客户端进行证书校验，如有效则生成随机数3，并用公钥加密;无效则警告 客户端-&gt;服务器 加密的随机数3 服务器使用私钥解密随机数3 客户端和服务器分别综合前三个随机数生产SESSION ID，用来加密整个的对话流程。 参考： https://www.jianshu.com/p/8fe93a14754c http://blog.csdn.net/a19881029/article/details/14002273 http://www.mahaixiang.cn/internet/1233.html https://www.wosign.com/faq/faq2016-0309-04.htm http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html]]></content>
      <categories>
        <category>技·术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java IO学习笔记]]></title>
    <url>%2F2018%2F03%2F19%2Fnote-java-io%2F</url>
    <content type="text"><![CDATA[概览 字节流字节流基础类InputStreamread系列方法：读取一个或多个字节。 OutputStreamwrite系列方法：写入指定内容的数据。 flush：强制写入缓存 拓展一：针对数据源的继承针对不同的数据来源，InputStream和OutputStream存在不同实现： 基于内存：ByteArrayInputStream和/ByteArrayOutputStream 基于磁盘文件：FileInputStream和FileOutputStream 基于网络：SocketInputStream和SocketOutputStream 拓展二：功能增强拓展在第一步拓展的基础上，分别对各类进行功能拓展。 装饰器模式扩展 通过FilterInputStream/FilterOutputStream实现装饰器模式。 责任链模式扩展 FilterInputStream / FilterOutputStreamFilterInputStream本身不实现输入流的功能，而是通过构造函数传入另一个InputStream的子类，把输入流的功能交给它做。通过继承FilterInputStream可以对输入输出流的行为进行扩展，这是装饰模式的典型用法。通过多个装饰类实现责任链模式，它将对一个输入流的不同处理分散到不同的FilterInputStream中去。FilterOutputStream和FilterInputStream的原理一样。 BufferedInputStream / BufferedOutputStreamBufferedInputStream继承了FilterInputStream，实现了输入流处理中的缓冲的功能。底层的流会先被读取到一个字节数组中，用户使用BufferedInputStream读取数据的时候，会先读取字节数组中的数据，读完了才会调用底层的流进行进一步的读取。这种方法可以提升读取的性能。 BufferedOutputStream继承了FilterOutputStream，实现了输出流处理中的缓冲功能。当用户写入数据的时候，其实是先写入到BufferedOutputStream的一个字节数组中，当这个字节数组满了，才会真正调用底层的输出流执行输出动作。这种方法可以提升写入的性能。在使用BufferedOutputStream的写入功能时，一定要使用flush，因为缓冲数组不满的时候是不会写入底层流的，在写入最后一点数据的时候，缓冲数据不一定被填满，这时候就需要调用flush进行强制刷新。 DataInputStream / DataOutputStream这两个类继承了FilterInputStream/FilterOutputStream，用来实现将java基本类型转换成二进制来进行读写操作，这两个类的readUTF和writeUTF方法使用了一种特殊的UTF编解码方式，只能用于java程序，因此不建议在网络流或者跨平台的应用中使用者两个类。 字节流小结Java I/O设计者通过装饰模式和责任链模式扩展了I/O的行为，实现这种扩展的基石是FilterOutputStream和FilterInputStream。也正是因为这两种设计模式，让我们写的Java I/O代码变成了下面这样的： 1InputStream in = new GZIPInputStream(new BufferedInputStream(new FileInputStream("1.txt"))); 最里面的FileInputStream是真正的数据来源，而BufferedInputStream和GZIPInputStream都继承了FilterInputStream对I/O的行为进行了改变。 字符流Reader / Writer 概览出现字符流的原因字节流面向字节，而人类面向字符。所以Java设计者重新设计了面向字符的IO。 字符与字节的转换计算机只能识别字节，于是需要设计者将Reader/Writer和InputStream和OutputStream进行打通，于是就有了InputStreamReader和OutputStreamWriter。 字符流基础类Readerread()系列：读取一个或多个字符的方法 Writerwrite系列：写入一个或多个字符 拓展一：对Reader/Writer的继承首先InputStreamReader/OutputStreamWriter继承自Reader和Writer。根据不同数据源，字节流类似，存在 文件读写字符流：FileReader/FileWriter 字符数组读写字符流:CharArrayReader/CharArrayWriter 拓展二：对Reader/Writer行为的拓展：类似字节流，也使用了装饰器和责任链模式。 参考： https://www.cnblogs.com/keyi/p/7171664.html https://www.jianshu.com/p/c4d3ef8004a7]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180319]]></title>
    <url>%2F2018%2F03%2F19%2Fdiary20180319%2F</url>
    <content type="text"><![CDATA[12:14:30 总是迷之缺乏自信，需要解决办法。 独居的日子里，只要打开电脑，就会因为流畅的打字而略感开心。 12:48:46 哭笑不得，老师昨天通知2点半开会，于是打算在家学，开完会再去咖啡店；现在老师竟然有事，竟然取消了…好吧，动身。 13:54:45 来到凯李咖啡，刷了一会微博。终于把最近的事情同步了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[qa-java-framework-mybatis]]></title>
    <url>%2F2018%2F03%2F18%2Fqa-java-framework-mybatis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[qa-java-framework-spring]]></title>
    <url>%2F2018%2F03%2F18%2Fqa-java-framework-spring%2F</url>
    <content type="text"><![CDATA[Q：什么是控制反转？原理是什么？控制反转前：我们主动创建对象，依赖对象 控制反转后：让容器帮忙管理。 如何告知容器对象与对象的关系？ 通过xml，properties等配置文件来描述，可能放在classpath，文件系统，或者是url资源。 如何解析文件？ 不同的配置文件对对象的描述方式不一样，标准的，自定义声明的，需要转换为内部需要统一定义方法BeanDefinition。 源码级别的说明: 关于Bean的定义，在Context的Beans包下边。 IOC：最核心的是BeanFactory接口，描述了对Bean的存取和判断等方法。定义了IOC的基本功能规范。 Spring定义了很多层次的接口，每个接口对对象做了不同的限制，都有使用的场合。比如ListableBeanFactory 表示这些Bean是可列表的，AutowireCapableBeanFactory 定义了Bean的自动装配规则。 ApplicationContext是一个高级IOC容器，除了基本功能外还提供了其他服务，国际化，访问资源等。 Q：IOC容器的启动流程？A： 定位，加载，注册。 定位和加载：首先各类资源都被抽象为Resource接口，通过各种输入流来读取文件并解析，通过loadBeanDefinition转换为BeanDefinition Q：AOP的原理？A： 通过代理模式实现，支持JDK动态代理（默认），和CGLIB代理。 JDK动态代理：实现InvocationHandler接口，实现其中的invoke方法，在其中定义目标方法定义前后的操作。并接收目标对象。使用时用代理绑定接口实现类，返回目标对象；通过目标对象调用方法，则会一并执行invoke方法中实现的逻辑。 DK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法； CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理； Bean的作用域有哪些？A： 不同版本有不同的种类。 在spring 3中，有五种。单例，原型；request，session，global session。 在spring 4和spring 5中，增加了websocket。 Q：事务的传播行为？A： 事务的传播行为，指的是多个事务方法相互调用时，事务如何在这些方法间传播。 参考Spring 3。 REQUIRED：业务方法需要在一个事务中运行。如果方法运行时，已经处在一个事务中，那么这个时候就会加入到该事务中，如果当前没有事务环境的话，就会为自己创建一个新的事务。默认情况下，业务方法的事务传播属性就是REQUIRED。在应用开发中，80%的情况下都会使用这种事务传播属性。 NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为它开启事务。如果方法在一个事务中被调用(在其他业务bean的方法中被调用了，而其他业务bean的方法是开启了事务的)，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行。 REQUIRESNEW：该属性表明不管当前是否存在事务，业务方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务会被挂起，新的事务会被创建，直到方法执行结束，新事务才算结束，原先的事务才会恢复执行。 MANDATORY：该属性指定业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果业务方法在没有事务的环境下调用，容器就会抛出异常。 SUPPORTS：这一事务属性表明，如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分。如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行。即当标注了事务传播属性——SUPPORTS的业务方法在另一个bean的业务方法中执行时，如果另一个bean的业务方法开启了事务，那么执行到标注了事务传播属性——SUPPORTS的业务方法时，它就会处在事务中执行，如果另一个bean的业务方法也没开启事务，那么标注了事务传播属性——SUPPORTS的业务方法也在没有事务的环境中进行。 Never：指定业务方法绝对不能在事务范围内执行。如果业务方法在某个事务中执行，容器会抛出异常，只有业务方法没有关联到任何事务，才能正常执行。 NESTED：如果一个活动的事务存在，则当前方法运行在一个嵌套的事务中。 如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效果。 参考资料： 官方文档 3.2.18 4.3.14 5.0.4 博客 https://www.cnblogs.com/ITtangtang/p/3978349.html#a1]]></content>
      <categories>
        <category>技·术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机学习笔记]]></title>
    <url>%2F2018%2F03%2F18%2Fnote-java-jvm-command%2F</url>
    <content type="text"><![CDATA[常见信息查看参数： 参数 作用 -XX:+PrintGC 每次GC之前的堆已用量，GC之后的堆已用量，当前可用堆空间，本次GC花费的时间 -XX:+PrintGCDetails 更加详细，显示每个区域的回收情况 -XX:+PrintHeapAtGC 更全面，在每次GC前后分别打印堆的信息。 -XX:+TraceClassLoader 跟踪类的加载 -XX:+TraceClassUnloading 跟踪类的卸载 -verbose:class 跟踪类加载和卸载 堆内存分布 最大堆和初始堆的配置当Java进程启动时，可用参数-Xms指定初始堆的大小，虚拟机会尽可能在初始堆空间内运行，扩展上线为最大堆空间，由-Xmx指定。 可以直接用-Xms和-Xmx将初始堆和最大堆设置为相等，减少GC次数，提高程序性能。 新生代的配置可以使用-Xmn设置新生代的大小。新生代过大会减少老年代的大小，对GC有很大影响。新生代大小一般配置为整个堆空间的1/3到1/4。 参数-XX：SurvivorRatio来设置新生代中eden与from/to空间的比例关系。含义为：-XX:SurvivorRatio=eden/from=eden/to 堆溢出处理使用参数-XX:+HeapDumpOnOutOfMemoryError,导出整个堆信息。使用-XX:HeapDumpPath 指定导出堆的存放路径。 常见回收算法引用计数法描述：为每个对象分配一个计数器，等于引用它的对象的数量。一旦为0则回收。 缺点： 无法解决循环引用 计数的增加或减少，会影响性能。 标记清除法描述： 从根节点出发，标记所有从根节点开始的可达对象； 清除所有未标记的对象。 优点：解决循环引用 缺点：回收后空间不连续，再分配时，不连续的内存工作效率降低。 复制算法描述： 将原有的内存空间分为两块，每次只使用其中一块 垃圾回收时，将正在使用的内存空间中的存活对象复制到未使用的内存块中，清除正在使用的内存块中的所有对象。 交换角色。 开销：复制存活的对象（多）、清除垃圾对象（少） 优点：没有碎片。 缺点：系统内存折半。 适合：在存活对象少，垃圾对象多的情况下高效。 标记压缩法或称 标记清楚压缩法 描述： 从根节点出发，标记所有从根节点开始的可达对象； 将所有存活的对象压缩到内存的一端 清理边际外所有空间 优点： 避免了碎片的产生 不需要两块相同的空间 性价比较高 分代算法描述： 将内存区间根据对象的特点分成几块，根据每块内存的特点使用不同的算法。 具体到Java堆内存： 新建对象放入新生代，90%会很快回收，适合使用复制算法。 一个对象经过几次回收后依然存活，放入老年代，是常驻内存的，可以用标记清除/压缩算法。 重要函数finalize()方法：所属对象： 在Object类中定义，所有类都继承了它。子类可以覆盖它，以整理系统资源或进行其他清理工作。 调用者： 垃圾回收器 调用时机： 当垃圾回收器发现一个对象没有任何引用时调用它；或者说是在垃圾回收器在删除对象之前调用它的。具体来说，是在Java虚拟机发现去除那些已经被执行了finalize的对象之外，没有任何活动的线程能够引用到该对象的时候调用。 作用： Object类的finalize方法没有做任何事，只是简单的返回。Object的子类可以重写它。 可以做任何事，甚至让该对象重新被其他线程引用。 一般来说，此方法的目的通常是要让该对象在回收之前做一些清理工作，比如代表输入/输入链接的对象在此时中断连接。 结果： 一个对象的finalize方法被调用之后，这个对象就不可以被任何活动的线程再次引用了，这个对象也不能再进行任何的操作，包括被那些已经执行finalize方法的对象或者类，直到被Java虚拟机回收。 调用次数： 一个特定的对象的finalize方法绝对不会被Java虚拟机调用超过一次。 不推荐使用的原因： 有可能发生引用外泄，无意中复活对象 此方法被系统调用，调用时间不明确，不是好的资源释放方案。 推荐的资源释放方案： 在try-catch-finally中进行。 System.gc()解释： 建议jvm对那些需要被清楚但尚未调用finalize方法的调用finalize方法。 与Runtime.getRuntime().runFinalization()等价。 垃圾回收器串行回收器并行回收器CMS(Concurrent Mark Sweep，并发标记清楚)回收器G1回收器优化方法汇总堆参数配置基本策略：尽可能将对象预留在新生代，减少老年代GC的次数。 扩大堆内存，减少 Full GC 。参数：-Mmx 使用并行回收器（ParrellOldGC）代替串行回收器: 升级虚拟机版本 类加载系统类加载过程 加载 连接 初始化 其中连接又分为： 验证 准备 解析 ClassLoader作用： 通过各种方式将Class信息的二进制数据读入系统，教给Java虚拟机进行连接、初始化。 ClassLoader分类 名称 名称 加载目录 使用权限 BootStrap ClassLoader （启动类加载器） JRE_HOME/lib如rt.jar 无Java实例，开发者无法使用 Extension ClassLoader （扩展类加载器） JRE_HOME/lib/ext 开发者可以直接使用 App ClassLoader （应用类加载器，系统类加载器） CLASSPATH 开发者可以直接使用 启动类加载器是系统级实现，完全由C实现，没有Java实例，无法获得实例。 双亲委托模型描述： 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 意义： 防止内存中出现多份同样的字节码。首选用BootStrap尝试加载。 弊端： 顶层的ClassLoader无法访问底层ClassLoader加载的类，即系统类访问应用类会出问题。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180318]]></title>
    <url>%2F2018%2F03%2F18%2Fdiary20180318%2F</url>
    <content type="text"><![CDATA[16:04:56 到图书馆借了两本书。 今天的运气实在不好，没有可以去的店，只能回家。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程学习记录]]></title>
    <url>%2F2018%2F03%2F17%2Fnote-java-concurrent%2F</url>
    <content type="text"><![CDATA[Q：如何创建一个线程？A： 实现Runnable接口，实现run()方法。实例化Thread对象，将实现Runnable接口的对象传入。// 常用 继承Thread类，重写run()方法。// 一个类一般仅在需要被加强或修改时才被继承，故一般不采用。 实现Callable接口，重写call()方法。// 1.提供返回值 2.可以抛出异常 3.可以进行异步计算 Q：线程的状态有哪些？生命周期是怎样的？A： 事实上在java.lang包下，Thread类内部维护着一个枚举类 Thread.State ，对此进行了明确的定义。 NEW 线程尚未开始。 RUNNABLE 正在虚拟机中执行，但可能正在等待操作系统中的其他资源。 BLOCKED 阻塞中，正在等待监视器锁。 WAITING 无限期等待另一个线程执行特定的动作。 TIMED_WAITING 等待另一个线程执行完指定时间的动作。 TERMINATED 已退出。 Q：如何终止线程？A： interrupt()方法。 Q：yield()是什么？A： 它们都会通知JVM这个线程可以释放CPU了。但JVM不保证遵循yield()的通知。通常yield()方法只做调试使用，用来复现与竞态条件相关的bug。 Q：说说对wait()、notify()和notifyAll()的理解？A： 三者都是Object类的final native方法。 作用： wait方法阻塞当前线程，而notify是唤醒被wait方法阻塞的线程。 使用前提： 当前线程必须获其对象的monitor（俗称“锁”），否则会抛出IllegalMonitorStateException异常，所以这两个方法必须在同步块代码里面调用，经典的生产者和消费者模型就是使用这两个方法实现的。 Q：线程池的作用是什么？为什么要用线程池？A： 频繁创建/销毁线程大大降低系统效率。 线程池可以复用线程，执行完一个任务，并不被销毁，而是可以继续执行其他任务。 作用： 降低资源消耗——复用以减少创建和销毁的开销 提高响应速度——当任务到达时，可以不需要等到线程创建就执行 提高线程的可管理性——可以对线程进行统一的分配、调优、监控，防止消耗过多内存 实现方法论： 可以直接参阅ThreadPoolExecutor类的构造方法。 线程池中，线程总数 = 核心线程数 + 非核心线程数。 核心线程： 就算闲置一直存活在线程池中，除非设定某些参数。具体来讲，将allowCoreThreadTimeOut设置为true，超过一定时间（可设置），则被销毁。 非核心线程： 如果闲置状态的时长超过keepAliveTime参数所设定的时长，就会被销毁掉 任务队列： 与闲置的概念相关。当所有核心线程都在运行时，新添加的任务会被添加到这个队列中等待处理。如果队列满了，则新建非核心线程执行任务。也就是说，任务队列保存着即将成为核心线程的任务。 ThreadPoolExecutor的策略 线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务 线程数量达到了corePools，则将任务移入队列等待 队列已满，新建线程(非核心线程)执行任务 队列已满，总线程数又达到了maximumPoolSize，则由RejectedExecutionHandler抛出异常。 Q：java自带的线程池？A： Executors类中提供了一些静态工厂类，生成一些常用线程池。 newSingleThreadExecutor单线程线程池。只有一个线程在工作。串行执行所有任务。 newFixedThreadPool固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 newCachedThreadPool可缓存线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 newScheduledThreadPool大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 Q：线程池的配置方法/实现原理？A： 抽象来看，所有线程池都是ThreadPoolExecutor构造方法的不同传参调用。 在调用Executors.newFixedThreadPool方法时，实际上是返回了一个新建的ThreadPoolExecutor类。 12345678public class Executors &#123; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125;...&#125; 也就是说，ThreadPoolExecutor是Executor的底层实现。 12345678//class ThreadPoolExecutorpublic ThreadPoolExecutor(int corePoolSize, //池中保存的线程数，包括空闲线程 int maximumPoolSize, //池中允许的最大线程数 long keepAliveTime, //当线程数大于核心时，终止前多余的空闲线程等待新任务的最长时间 TimeUnit unit, //keepAliveTime参数的时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务 ThreadFactory threadFactory, //执行程序创建新线程时使用的工厂 RejectedExecutionHandler handler) //由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 Q：怎样优化线程池？A： 一般说来，大家认为线程池的大小经验值应该这样设置：（其中N为CPU的个数） 如果是CPU密集型应用，则线程池大小设置为N+1 如果是IO密集型应用，则线程池大小设置为2N+1 Q：Java的对象模型是怎样的？与线程有什么关系？A： Java的对象存储在堆内存中。一个Java对象包含三部分：对象头，实例数据和元数据，以C++代码的形式存在。 其中对象头是很关键的部分，其中包含一些运行时数据，和与多线程相关的锁是信息，包括锁状态标志、线程持有的锁等标志。 Java在内存中的表示，最方便的方式是直接对应一个C++类。但是HotSpot没有这么做，因为HotSpot JVM的设计者不想让每个对象都含有一个虚函数表（vtable）。那么怎样表示呢？答案是OOP-klass Model。 对象头在HotSpot中的markOop.hpp中表示。关键代码如下： 12345678enum &#123; age_bits = 4, lock_bits = 2, biased_lock_bits = 1, max_hash_bits = BitsPerWord - age_bits - lock_bits - biased_lock_bits, hash_bits = max_hash_bits &gt; 31 ? 31 : max_hash_bits, cms_bits = LP64_ONLY(1) NOT_LP64(0), epoch_bits = 2&#125;; 从上面的枚举定义中可以看出，对象头中主要包含了GC分代年龄、锁状态标记、哈希码、epoch等信息。 对象头最重要的部分是mark word。它非常像协议报文头。 从上图中可以看出，对象的状态一共有五种，分别是无锁态、轻量级锁、重量级锁、GC标记和偏向锁。在32位的虚拟机中有两个Bits是用来存储锁的标记为的，但是我们都知道，两个bits最多只能表示四种状态：00、01、10、11，那么第五种状态如何表示呢 ，就要额外依赖1Bit的空间，使用0和1来区分。 在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，表示非偏向锁。 markOop.hpp类中有关于对象状态的定义： 123456enum &#123; locked_value = 0, unlocked_value = 1, monitor_value = 2, marked_value = 3, biased_lock_pattern = 5&#125;; 即 12345locked_value (00) = 0unlocked_value (01) = 1monitor_value (10) = 2marked_value (11) = 3biased_lock_pattern (101) = 5 Q：什么是锁，它是怎样实现的？A： 在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。 Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象。 在Java虚拟机(HotSpot)中，Monitor是基于C++实现的，由objectMonitor实现的，其主要数据结构如下： 123456789101112131415161718ObjectMonitor() &#123; _header = NULL; _count = 0; _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ;&#125; 其中值得关注的属性： 12345_owner： 指向持有ObjectMonitor对象的线程_WaitSet： 存放处于wait状态的线程队列_EntryList： 存放处于等待锁block状态的线程队列_recursions： 锁的重入次数_count： 用来记录该线程获取锁的次数 Q：什么是ThreadLocal？有什么作用？参考：原文 翻译 A： 一个线程（Thread）是无法持有变量的，想要让这个线程与某个变量相关，需要用到ThreadLcoal。 ThreadLocal可以理解为一种容器，从其构造方法可以为泛型就可以看出来。 一般用一个典型的MyThreadLocal类来管理ThreadLocal。 123456789101112131415public class MyThreadLocal &#123; public static final ThreadLocal&lt;Context&gt; userThreadLocal = new ThreadLocal&lt;&gt;(); public static void set(Context cxt) &#123; userThreadLocal.set(cxt); &#125; public static void remove() &#123; userThreadLocal.remove(); &#125; public static Context get() &#123; return userThreadLocal.get(); &#125;&#125; 而在运行时，每个线程中的业务逻辑都可以从此ThreadLocal取得与当前线程相关（set）的数据。 参考文章： http://www.hollischuang.com/archives/1910 http://www.hollischuang.com/archives/1953 http://www.hollischuang.com/archives/2030 https://www.oschina.net/question/565065_86540 https://www.jianshu.com/p/210eab345423]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180317]]></title>
    <url>%2F2018%2F03%2F17%2Fdiary20180317%2F</url>
    <content type="text"><![CDATA[12:13:39 来到凯李咖啡。不知不觉写日记已经有一个月了。从开始的零零散散，到现在每天几乎只有一句话，好歹也坚持下来了。 21:53:40 第二次泰坤，爽快。以后要带水。 预定了下周日的环太平洋电影。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap Q & A]]></title>
    <url>%2F2018%2F03%2F16%2Fqa-java-hashmap%2F</url>
    <content type="text"><![CDATA[首先要明白Map的概念。通过查看Map接口可以发现Map内部维护着Entry接口，这个Entry才是真正维护着键值对的结构，Map中的其他方法只是提供了一些视角（view），我们知道一个Map中维护着多个键值对，实际上就是维护着多个Entry。 接下来看HashMap。首先要明白Hash的概念。 Hash的意思就是散列，抽象的作用是把任意长度的输入转换为指定范围内的输出。从面向对象编程的视角看，hash有两个步骤：第一步，将想要存储的对象（也就是key）转换为一个整数（也就是散列码）；第二步，将这个整数压缩至数组长度内合理的索引值。 从这里引出五个主要问题： 如何获取对象的散列码？ 如何获取元素索引值？ 如何维护数组的长度？ Q：如何获取对象的散列码？A： 对象分为三类来看：类类型，字符串，基本类型。 对于类类型，由于每个类都是Object的子类，都有一个hashCode方法。这个方法可以返回根据这个对象内存地址的一个int值，直接作为散列码。 对于字符串，想象空间很大，可以取Unicode值来进行计算，但是要考虑到现实世界中字符的分布不是均匀的。有种比较理想的方法称为Horner法： 取质数g，遍历此字符串中每个字符，每遍历一个就增加（这个字符Unicode值 g 索引值），最终的和就是散列码。 在String类中，这个因子等于31。原因是 n * 31 = n &lt;&lt; 5 - n ，在JVM中会被优化的非常快。 对于基本类型： 对于int类型，可以直接用其本身作为散列码。如果是其他基本类型，可以利用其内部的二进制表示。 如果是long类型，它含有64位二进制数据，而int含有32位，如果直接转换为int会丢失前32位，所有只在前32位有区别的数据都将产生冲突。在java中的解决方案是，将这64位的二进制数据，与其右移32位的结果做位与运算。这样就把前后32位都利用了。代码： 123public static int hashCode(long value) &#123; return (int)(value ^ (value &gt;&gt;&gt; 32));&#125; 对于double和float，都可以以类似的方法处理。 Q：如何确定索引值？事实上这一步才是hash的典型操作。此时的散列码是一个int类型的值，从 -232 到 -232 ，而数组容量往往远小于此。因此需要进行压缩。 一般情况下将散列码对范围值取模即可，结果就比较均匀，但是假如key值成等差数列分布，就会使冲突率大大增加。Java对此进行了优化，将散列码进行了二次处理，取模方式也做了优化。请参考下一个问题。 Q：如何维护数组长度？A： 数组长度的维护，主要以性能为目标。从以下角度考虑数组的长度维护问题： 确定索引值时的取模操作性能 扩容问题 考虑取模操作的性能： 在获取索引值时，需要将散列码对数组长度取模。注意到，如果length的值为2的n次方，那么 hashcode % length = hashcode &amp; (length -1) 。很容易发现后者的位操作是效率很高的。为此，有必要将数组长度维护为2的n次方。在源码中有如下体现：1）数组的默认容量(initialCapacity)的值是16。2）如果初始化的时候指定了数组容量，则程序会寻找不小于给定容量的最接近2的n次方的值。 散列码的二次处理 假如给定的key成等差数列，那么这些key的散列码有可能后几位全部相同，冲突率大大增加。而事实上hashcode &amp; (length -1)是忽略了hashcode的高位的。为了解决这一问题，需要将hashcode的高位也利用起来。类似刚刚long类型取散列码的方法，此时的散列码是int类型，为了将其高16位也利用起来，可以将散列码与其右移16位的结果取位与，得到新的散列码。此时即可避免等差数列的漏洞。这就是上文提到的二次处理的散列码，即高位运算。源码： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 扩容性能对长度的影响： 随着元素增多，数组逐渐填满，冲突的概率会越来越大，因此不能等到数组满了再扩容；而每次扩容会有一定开销，所以扩容需要在适当的时机。HashMap类维护了几个扩容相关的概念：capcacity，loadfactor，threshold，后者等于前两者的积，代表当前数组中可容纳的最多相同hashcode的Node数。加载因子默认为0.75，也就是当元素个数达到数组长度的0.75时，将进行扩容，即将当前长度 * 2。显然长度仍然是2的n次方。 如何扩容？ 每次扩容令数组长度变化，那么每个元素的位置也会发生变化，原本因冲突而形成链表或红黑树的Node的位置也需要重新计算。下面对比JDK7和JDK8来说明resize机制。 在JDK7中，一旦扩容，就需要对所有元素rehash。而且旧链表迁移到新链表时,如果在新表的索引位置相同，链表元素会倒置。 而在JDK8中，神奇的事情发生了。因为数组长度总是保持在2的n次方，扩容之后，数组长度的二进制表示就是原有数值左移一位，length-1的二进制表示的最高位的左边一位置1。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 此时获取索引的计算 hashcode &amp; (length -1) 变成了 原索引+oldCap，性能获得提升。这就是JDK8中对resize的优化。 其他问题Q：get方法的流程是怎样的？A： 调用key的hashcode方法获取hash值 对hash值做高位运算处理 将处理后的hash值对数组长度取模，得到索引 遍历链表，用key的equals方法与每个元素比较，匹配成功则返回。 Q：怎样优化HashMap的性能？A： 使用包装类作为key。此类wrapper类是final类型的，已经重写了equals和hashCode方法，碰撞的几率更小，散列更为高效。 Q：并发会导致什么问题？A： 多线程操作可能导致死循环。 HashMap是非线程安全的。一般来说，链表出现死循环很可能是因为出现环形链表。所以可以从这个角度考虑问题。 具体来讲，向HashMap中添加元素时，在resize的时候，需要调整原有的元素到新的位置，即transfer方法。在此方法中，对于某个特定索引的链表，如果多个线程切换执行此方法，由于每个线程对next进行重复操作，导致形成环状链表。 解决方案： 使用Collections.synchronizedMap(Mao m)方法把HashMap变成一个线程安全的Map。 使用ConcurrentHashMap。 Q：与HashSet的区别是什么？A： HashSet仅仅存储对象，而不存储键值对，相对较慢。 Q：与HashTable的区别？A： HashTable继承了Dictionary接口，线程安全，其中涉及存取的方法都加上了Synchronize关键字。 ConcurrentHashMap相关问题Q：ConcurrentHashMap的数据结构？A： 实现了ConcurrentHashMap接口。 与HashMap一大不同是，内部实现了Map.Entry的节点Node其中的next和value是volatile的，避免了Hashmap中的死循环。 参考：Java 8系列之重新认识HashMap]]></content>
      <categories>
        <category>技·术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180316]]></title>
    <url>%2F2018%2F03%2F16%2Fdiary20180316%2F</url>
    <content type="text"><![CDATA[12:29:50 来到凯李咖啡。果然和在家非常不一样。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用算法记录]]></title>
    <url>%2F2018%2F03%2F16%2Fquick-adt-useful%2F</url>
    <content type="text"><![CDATA[在线IDE 排序冒泡排序1234567891011public void bubbleSort(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = i; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j+1]) &#123; int tmp = array[j+1]; array[j+1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738public void quickSort(int[] array) &#123; quickSort(array, 0, array.length - 1, 0);&#125;/*** 每次操作的结果：左边的值&lt;=基准值&lt;=右边的值，也就是将基准值归位**/private void quickSort(int array[], int lo, int hi, int pivot) &#123; if (lo &gt;= hi) &#123; return; &#125; int i = lo; int j = hi; //4.重复执行，直到i和j相遇并交错。此时j在i的左边一个。 while (i &lt; j) &#123; //1.把j移动到从右到左第一个比基准值小的位置。 while ((i &lt; j) &amp;&amp; (array[j] &gt;= array[pivot])) &#123; j--; &#125; //2.把i移动到从左到右第一个比基准值大的位置。 while ((i &lt; j) &amp;&amp; (array[i] &lt;= array[pivot])) &#123;//必须把范围判断放在前面 i++; &#125; //此时j一定不在i的右边，并且j对应的值比i小，所以无需判断i与j的关系 int tmp1 = array[i]; array[i] = array[j]; array[j] = tmp1; &#125; //5.基准值是比较对象，位置不会随比较而变化，故需 int tmp2 = array[lo]; array[lo] = array[j]; array[j] = tmp2; quickSort(array, lo, j - 1, lo); quickSort(array, j + 1, hi, j + 1);//必须是j+1，否则如果是顺序序列，会无限循环&#125; 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void mergeSort(int[] array) &#123; mergeSort(array,0,array.length-1);&#125;public void mergeSort(int[] array, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; int midLeft = (lo + hi) / 2; //先分割，再归并 mergeSort(array, lo, midLeft); mergeSort(array, midLeft + 1, hi); merge(array, lo, midLeft, hi);&#125;private void merge(int[] array, int lo, int midLeft, int hi) &#123; int[] newArray = new int[hi - lo + 1]; int i = lo; int j = midLeft + 1; int newArrayPointer = 0; while (i &lt;= midLeft &amp;&amp; j &lt;= hi) &#123; if (array[i] &gt; array[j]) &#123; newArray[newArrayPointer] = array[j]; newArrayPointer++; j++; &#125; else if (array[i] &lt;= array[j]) &#123; newArray[newArrayPointer] = array[i]; newArrayPointer++; i++; &#125; &#125; while (i &lt;= midLeft) &#123; newArray[newArrayPointer] = array[i]; newArrayPointer++; i++; &#125; while (j &lt;= hi) &#123; newArray[newArrayPointer] = array[j]; newArrayPointer++; j++; &#125; newArrayPointer = 0; for (int k = lo; k &lt;= hi; k++) &#123; array[k] = newArray[newArrayPointer]; newArrayPointer++; &#125;&#125; 二叉树先序遍历“乡”字型遍历。根左右。 递归版： 12345678910void preOrderTraversal(TreeNode root)&#123; if(root=null)&#123; return; &#125; //对root进行操作 // doSth(root); // preOrderTraversal(root.leftNode); preOrderTraversal(root.rightNode);&#125; 迭代版： 12345678910111213141516171819public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); s.push(root); while (!s.isEmpty()) &#123; TreeNode node = s.pop(); list.add(node.val); if (node.right != null) &#123; s.push(node.right); &#125; if (node.left != null) &#123; s.push(node.left); &#125; &#125; return list;&#125; 中序遍历左根右 递归版： 12345678910void inOrderTraversal(TreeNode root)&#123; if(root=null)&#123; return; &#125; preOrderTraversal(root.leftNode); //对root进行操作 // doSth(root); // preOrderTraversal(root.rightNode);&#125; 迭代版 123456789101112131415161718public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null)&#123; return list; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); while(!s.isEmpty()||root!=null)&#123; if(root!=null)&#123; s.push(root); root=root.left; &#125;else&#123; root = s.pop(); list.add(root.val); root=root.right; &#125; &#125; return list;&#125; 后序遍历右根左 12345678910void postOrderTraversal(TreeNode root)&#123; if(root=null)&#123; return; &#125; preOrderTraversal(root.leftNode); preOrderTraversal(root.rightNode); //对root进行操作 // doSth(root); //&#125; 层序遍历使用队列 123456789101112131415161718192021public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(root==null)&#123; return list; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode treeNode = queue.poll(); if (treeNode.left != null) &#123; queue.offer(treeNode.left); &#125; if (treeNode.right != null) &#123; queue.offer(treeNode.right); &#125; list.add(treeNode.val); &#125; return list; &#125;&#125; 123456789101112131415161718192021public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; queue.add(root); while (queue.size() != 0) &#123; TreeNode temp = queue.remove(0); if (temp.left != null)&#123; queue.add(temp.left); &#125; if (temp.right != null) &#123; queue.add(temp.right); &#125; list.add(temp.val); &#125; return list; &#125;&#125; 查找二分查找递归版 1234567891011121314151617public int binarySearch(int[] array, int target) &#123; return binarySearch(array, target, 0, array.length - 1);&#125;private int binarySearch(int[] array, int target, int lo, int hi) &#123; if (lo &gt; hi) &#123; return -1; &#125; int mid = (lo + hi) / 2; if (array[mid] == target) &#123; return mid; &#125; else if (array[mid] &gt; target) &#123; return binarySearch(array, target, lo, mid - 1); &#125; else &#123; return binarySearch(array, target, mid+1, hi); &#125;&#125; 迭代版 12345678910111213141516public int binarySearch(int[] array, int target) &#123; int lo = 0; int hi = array.length-1; while (lo &lt;= hi) &#123; int mid = (lo + hi) / 2; if (array[mid] == target) &#123; return mid; &#125; else if (array[mid] &lt; target) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; return -1;&#125; 链表常见算法翻转链表递归版： 123456789101112public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode newHead = null; if (head == null || head.next == null) &#123; return head; &#125; newHead = ReverseList(head.next); head.next.next = head; head.next = null; return newHead; &#125;&#125; 迭代版： 1234567891011public ListNode ReverseList(ListNode head) &#123; ListNode pre = null; ListNode next = null; while (head != null) &#123; next = head.next; //提前保存好next节点 head.next = pre; //把当前节点指向上一个节点，即翻转操作 pre = head; //保存当前节点为上一个节点，便于下次操作 head = next; //迭代。注意不能写成head=head.next，因为此时的head已经指向了pre，它的next会向相反方向迭代。 &#125; return pre;&#125; 算法总结对终止条件的思考： 每种算法的终止条件事实上都以“放宽”为标准。如二分查找的递归和迭代，在递归函数中，用if(lo&lt;hi) return来做终止条件，是把终止条件从相等放松到交错；在迭代函数中，用while(lo&lt;=hi)做循环入口，是把进入条件从交错放松到相等。]]></content>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的概念与辨析]]></title>
    <url>%2F2018%2F03%2F16%2Fnote-adt-tree%2F</url>
    <content type="text"><![CDATA[树的相关概念节点的度（degree）： 一个节点的（下一层）子节点个数 （在二叉树中，范围为0~2）树的度： 树的节点中，度数最大的节点，的度数。节点的深度： 从根节点向下，累加值节点的高度： 从叶节点向上，累加值树的高度（深度）： 树中节点最大层数完全二叉树： 除了最后一层外，其余层都含有尽可能多的节点；且最后一层从左向右填满。 计算 树的所有的节点个数=所有节点的度数和 + 1 解释：所有节点的度数和=所有节点数-1（根节点） 度为m的树中第i层上至多有m^(i-1)个节点，i&gt;=1 树T的高度=1 + T的最高子树的高度 完全二叉树的高度与节点数的关系： log2(n+1)向上取整。满二叉树则为log2(n+1)。 高度 节点数 1 1 2 3 3 7 4 15 5 31 即 n = 2^h-1 或 h = log2(n+1) 树的节点数与高度成数列 an = 2n-1 或者说 N = 2h-1 则 h = log2(N+1) 从数组到树的发展 数据结构 优势 限制 劣势 数组 下标寻址迅速 计算机内存有限，数组长度有限；查找最坏情况需要遍历整个数组 查找复杂度过高；插入和删除都比较复杂 链表 增删方便 结构复杂 查找耗时 二叉查找树 最好情况下查找复杂度较低 可能退化成链表 最坏情况下=链表 哈希表 数组和链表的折中 依赖散列函数的设计，数组不能无现场，链表不适合查找 不适合大规模查找 AVL树 查找稳定在O(logN) 旋转复杂 插入和删除较慢 红黑树 插入效率较高 平衡树与AVL树的折中 不易实现 各种二叉树的特点二叉搜索树（Binary Search Tree，BST）特点： 每个节点都满足，左孩子上所有节点 &lt; 该节点 &lt; 右孩子上所有节点。事实上，对二叉查找树进行中序（左根右）遍历，会升序输出。 时间复杂度分析： 查找： 平均(logN) 有序时O(N) 当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上 当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)/2，查找的平均时间复杂度在O(N)数量级上。 插入： 平均(logN) 有序时O(N) 新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。 删除： &lt;= O(logN) 当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的…的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN) 效率总结： 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。插入删除操作算法简单，时间复杂度与查找差不多。 优势： 中序遍历可以快速检索 劣势： 如果插入的节点本身是有序（如插入 [1,2,3,4,5,6]）时，成为单链表，查找效率无法接受。 平衡二叉搜索树（Adelson-Velskii and Landis，AVL）特点：带有平衡条件（左右两个子树高度差的绝对值不超过1）的二叉查找树。 时间复杂度分析： 查找：&lt;= O(logN) 查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。 插入：O(logN) AVL必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。 删除：O(2logN) AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN) 效率总结： 查找维持在O(logN)，不会出现最差情况 每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。 作用：很好的解决了二叉查找树退化成链表的问题。把插入、查找、删除的时间复杂度维持在O(log2N). 红黑树特点： 不是严格的平衡二叉树，放松了平衡二叉树的某些要求，提升了性能。 算法时间复杂度与AVL树相同，但统计性能比AVL树要高。 优势： 能够以O(log2N)的时间复杂度进行搜索、插入、删除操作。 任何不平衡都会在3次旋转内解决。 最坏情况依然是高效的。 劣势： 查找性能比AVL树稍差 插入和删除都需要一定的维护 实现：TreeMap 哈夫曼树（最优二叉树）参考：http://zhuanlan.zhihu.com/p/33481066 B树系列参考 https://www.cnblogs.com/gym333/p/6877023.html 特点：每个节点包含关键字和指针，关键字就是数据，指针指向下一层的节点。 B-tree特点：叶子节点是失败节点；在非叶子节点命中。 复杂度：渐进复杂度为O(logdN),其中d为大于1的整数。查找等价于在关键字做一次二分查找。 应用：一般用于数据库的索引，综合效率较高。 B+-TreeB+-Tree是B-Tree的变形，在文件索引方面更普遍。 特点： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统 性能：也等价于二分查找。 B*-Tree特点： 是B+-Tree的变体，在非根和非叶子节点再增加指向兄弟的指针。 分配新节点的概率比B+-Tree低，空间使用率更高。 Q：为什么要使用B+-Tree和B-Tree作为数据库的索引？A： 适合做索引的数据结构评价标准： 索引本身也很大，不可能全部存储在内存中，需要以索引文件的形式存储在硬盘上。这意味着查找过程产生I/O消耗，而磁盘I/O要比内存I/O消耗高几个数量级。所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中，磁盘I/O次数的渐进复杂度，或者说尽可能减少I/O次数。 磁盘读写原理： 根据局部性原理，主存与磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 计算： B/B*-Tree检索一次最多访问节点为： h = logm/2((n+1)/2)+1 数据库将一个节点的大小设为一个页，这样每个节点只需一次I/O即可完全载入，相邻的页即可利用局部性原理。 B-Tree一次检索最多需要h-1次I/O，渐进复杂度为O(h)=O(logmN),实际情况下m非常大，通常超过100，因此h非常小，通常不超过3。 而红黑树的h明显要深得多。由于逻辑上很近的节点可能物理上很远，无法利用局部性，所以红黑树的I/O渐进如咋读为O(h)，比B-Tree差很多。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary20180315]]></title>
    <url>%2F2018%2F03%2F15%2Fdiary20180315%2F</url>
    <content type="text"><![CDATA[10:40:57 华为开始春招了。 20:25:40 完全写完调研报告。deadline的力量真是太牛逼了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary20180314]]></title>
    <url>%2F2018%2F03%2F14%2Fdiary20180314%2F</url>
    <content type="text"><![CDATA[10:37:33 今天开始更换日记文件命名方式。继续论文。 19:52:54 霍金去世，也算是见证历史了。 19:58:41 这两天写毕业论文发现，其实数学是很美的，精确，简练，没有一点废话，不应畏惧。 22:38:41 天气逐渐回暖。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary180313]]></title>
    <url>%2F2018%2F03%2F13%2Fdiary20180313%2F</url>
    <content type="text"><![CDATA[11:36:48 今天尽量把论文完成。 1:30:12 调研报告写的还算顺利。果然常沟通非常必要。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary180312]]></title>
    <url>%2F2018%2F03%2F12%2Fdiary20180312%2F</url>
    <content type="text"><![CDATA[14:11:28 又是毕设检查……最近好像没有了一周开始的概念。 21:39:05 下午毕设检查，一如预期需要改动。从民主楼出来，叫上胡出来玩，从西二环绕到新校，又绕到阳光100，最后又回到步步高吃了鲜芋仙，竟然还看了电影。三块广告牌，看的不是很懂。刚刚吃了涮锅回来。明后两天要加急了。。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[难以习惯的孤独]]></title>
    <url>%2F2018%2F03%2F11%2Fdiary20180311%2F</url>
    <content type="text"><![CDATA[12:54:06 想法：写个脚本，每天自动生成diary 19:57:42 知乎上一些关于孤独的文字： 一个人的时候孤独，切勿以为两个人的时候就不会孤独。 当独处的时候，他是最自由的。 切勿去通过刺激感官的方法去消灭孤独。 做爱可以带来快乐，做题也可以带来快乐。但是两者的快乐并不一样，前者的快乐强烈而短暂，做完之后犹如黑夜中的烟火，亮完还需要面对无边无际的黑夜；而后者，深远而绵长，感觉生命因此而充实起来。 多输出，少输入。 看电影，被动接受声音和影像，是输入；看书的时候思考，是输出。躺在床上按摩，被动接受运动，是输入；自己去跑步，主动运动，是输出。 当我孤独时，多感受来自人自身带来的快乐，而非靠外部的刺激来充实你的精神。 20:08:37 有时简直不敢相信，也不想承认，我跟她已经分手四年了，她也早已结婚了……一个人太久，会让记忆断层，只要用力想想，就会直接回到那些时光。四年，读一个大学都读完了。时间会摧残一切，唯独记忆会越久越深。 是为什么呢？因为怀念，怀念真心心动的感觉。而只要我试图检索曾经有过的心动的瞬间，就会直接跳转到四年之前，拦都拦不住。 我总觉得自己还算理性，但是没想到在这么严肃的事情也会过渡缅怀。越是回想，就越是克制；越是克制，就越感孤独；越感孤独，就越是回想…… 有卖忘情水的吗？ 反过来想，我真的配吗？嗯，这样想，会好很多… 认清现实吧！回不去了！ BE A MAN！ 22:53:16 人是骗不了自己的。不管怎么想，这些杂念都必须终止。这是小孩子的贪恋情绪，早晚要终止，否则会酿成大祸。多多转移注意力吧。 23:01:21 闲时写写博客成了独居为数不多的乐趣了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[diary180310]]></title>
    <url>%2F2018%2F03%2F10%2Fdiary20180310%2F</url>
    <content type="text"><![CDATA[9:36:20 果然喝酒更容易作出不易决定的事情。 12:45:59 女生想要的是被保护，男生想做的是去征服…..于是他们靠近的结果不是结合，而是撞击，被巨大的力量反弹，循环几次，越弹越远。 16:14:05 来到库克咖啡。刚刚去听了Apollo的小分享会。 1:36:07 许浩考上了哈工大深研院。 朱星禹的孩子于2018年3月10日20点出生，母子平安。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈希·学习记录]]></title>
    <url>%2F2018%2F03%2F09%2Fnote-adt-hash%2F</url>
    <content type="text"><![CDATA[什么是哈希？柯林斯词典中对hash一词的解释是切碎或剁碎的意思： to chop into small pieces. 或者是一种习语，把事情搞得一团糟。 PHRASE If you make a hash of a job or task, you do it very badly. 因此，在计算机科学中，hash成为散列的代名词。 什么是散列？对比来看，要想从数组中查找元素，只需确定元素的索引，无需涉及其他数组元素。 散列也是如此，无需查找（遍历），只需根据键来确定元素索引，即可找到对应的元素。数组是散列的一种，是散列表。 什么是散列函数？散列函数的作用是转化。从键到索引值的转化过程，就是散列函数处理的。键可能是数字，可能是字符串，需要通过散列函数处理，转化为整数。 理想的散列是什么样子的？理想情况下，散列函数将每个键都映射到散列表（或称之为哈希表）中的唯一一个元素。比如键的范围是从0000到9999，散列函数产生从0到9999的整数，每个键对应唯一一个整数，也就对应相应的元素。此时的散列函数称为完美的散列函数。 实际情况下的散列是什么样子的？实际情况下，不是每个键都会派上用场。比如上例，键的范围是0000到9999，可实际用到的可能仅仅只有少数。比如，电话号码的范围是0000到9999，而实际拥有电话的人可能只有几百人。那么散列表就可能会是稀疏的，浪费了大量空间。 典型的散列函数？典型的散列函数需要进行下列两个步骤： 将查找键转换为一个称为散列码(hash code)的整数； 将散列码压缩到散列表的索引范围。 如： 12345//返回含tableSize个位置的数组的一个索引int getHashIndex(int num)&#123; int i = num的最后四位数字; return i % tableSize;&#125; 由于tableSize小于查找键的数量，所以某些键可能会映射到相同的索引，这一现象称为冲突。为了解决这一问题，需要处理冲突。 较好的散列函数？散列函数只需产生适合的整数，而解决冲突需要一定代价。这说明较好的散列函数应该： 使冲突最少 计算快 为了减少冲突的几率，散列函数应当使元素尽量均匀地分布在散列表中。 计算散列码类类型的散列码刚刚提到，典型的散列函数的第一步是将键转换为散列码。不仅是数字和字符串，任何类型的对象都可以作为键。在Java中，每个Object都有一个hashCode方法，用于产生散列码。 但是，这个默认的散列码不适合用于散列，因为对于两个 equal 的对象，它将产生不同的散列码。因此，应当自定义hashCode方法。准则如下： 如果一个类覆盖了方法equals方法，则应该覆盖hashCode方法。 如果equals方法认为两个对象相等，那么hashCode方法对它们必须返回相同的散列码。 如果在同一程序中对一个对象调用多次hashCode方法，且它们没有改变，必须返回相同的散列码。 在同一程序的两次执行过程中，对象的散列码可以不同。 注：一般情况下，虽然相等的对象有相同的散列码，但是不相等的对象也有可能有相同的散列码，此时产生冲突，应竭力避免。 字符串的散列码容易想到的方式有，为A~Z每个字母分配一个整数，或者用Unicode代替，散列函数取每个字符串开头的几个字母对应的整数。然而如果开头字母相同，则散列码相同。事实上，任何使用特定的字母的散列函数都无法将字符串均匀地分布在散列中。因为现实世界的数据不是均匀的。 更好的字符串散列码Horner法：每个字符的Unicode值乘以与这个字符位置有关的因子，散列码就是这些乘积之和。对于字符串s，设g为某一常数，u(0)到u(n-1)为每个字符，有 s = u(0)u(1)……u(n-1) hash = u(0)*g^(n-1) + u(1)*g^(n-2)+……+u(n-2)*g+u(n-1) 在某一版本的Java中，String类实现的hashCode方法是 12345int hash = 0;int n = s.getLength();for (int i = 0;i &lt; n;i++)&#123; hash = g * hash + s.charAt(i);&#125; 基本类型的散列码对于int，short，char，byte的基本类型，可以将他们转化为int，直接作为散列码。 对于其他基本类型，可以用内部的二进制表示。如果是long类型，则含有64位，如果简单的转换为int，或者将其对2^32取模，则会丢失前32位。结果是，所有只在前32位不同的键将有相同的散列码。这是我们不希望的。所以，我们要考虑到整个键，不要忽略它的一部分。 对于long类型对象，一种方法是，将它分开成若干部分，用各种位操作将这些部分结合起来。这称为折叠。 Java中的做法是 (int)(key^(key&gt;&gt;32)) 即，将key右移32位，并与它原本的值取位或运算。右移的步骤丢弃了高32位，位或的步骤将高低32位结合。最后转化为int，丢弃高32位。这样有效的利用了key的高低32位，也就是考虑了全部的元素。 对于double类型的操作是类似的，但需要借助Double.doubleToLongBits方法来获取key的位组合。 12long bits = Double.doubleToLongBits(key);int hashCode = (int)(bits^(bits&gt;&gt;32)) 对于float，散列码可以就是它的32位，通过调用Float.floatToIntBits(key)得到。 事实上，以上基本类型的散列计算已经包含在相应包装类的hashCode方法实现中。 将散列码压缩为散列表的索引将一个整数缩小至指定范围，最常用的就是取模运算。但是这不是理想的。考虑到一个特性：一个数在对偶数取模之后，奇偶性不会变化。而（例如）基于内存地址的散列码通常是偶数，索引可能不再均匀分布，而偏向偶数。因此，散列表长度只能是奇数。 当n为素数时，c % n 将等于0到n-1均匀分布值。 另外，hashCode可能会返回负值。范围是1-n到0，令结果加上n即可。 因此，我们可以有如下实现： 1234567private int getHashIndex(K key)&#123; int hashIndex = key.hashCode() % hashTable.length; if(hashIndex &lt; 0)&#123; hashIndex = hashIndex + hashTable.length; &#125; return hashIndex;&#125; 处理冲突处理冲突有两种选择： 使用散列表中的另一个位置。 修改散列表的结构，让每个数组位置可以表示多个值。 前者称为开放定址（open addressing），暂且不谈。 链地址每个数组的位置可以表示不知一个值，这样的位置被称为捅。而一旦涉及数组，则会有大量的内存消耗。而用链表实现桶是合理的选择，内存仅在需要时才分配。使用链表构成的桶处理冲突，被称为链地址。 代码实现]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自作多情的终局]]></title>
    <url>%2F2018%2F03%2F09%2Fdiary20180309%2F</url>
    <content type="text"><![CDATA[11:46:12 去卫生站拿了化验报告，疫苗生效。 与老爸的恶搞，哈哈哈哈 阳光正好哇。 下载了小米云同步助手。 21:30:16 身体异样记录：晚上不宜喝酒。喝酒接近困倦，浪费一堆时间。 21:44:26 无论何时的疲惫，只要换个话题，新鲜的，或者许久未提的，总能打气精神。 用上了wox，非常好用。 23:27:54 编程不能马虎的地方 1. 忘记终止条件的return 2. 比较对象从array[i]&lt;array[j]写成i&lt;j 1:39:56 删除了所有留言。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客类型与组织形式]]></title>
    <url>%2F2018%2F03%2F08%2Fthought-blog-better%2F</url>
    <content type="text"><![CDATA[博客的命名（文件名、url）在很大程度上决定了内容的组织形式，也会给后续的查阅带来影响。 博客计划采取以下系列命名方式： 内容 命名 日记 diary+序号 想法 thought+序号 技术原理或学习笔记 note+… 技术快速查询 quick+… debug 或问题解决方案 debug+… 常见情景的操作清单 list+… 算法题解 coding+内容 简历相关 cv+内容 目前而言，与我来讲，最好的博客应当起到以下作用： 学习吸收。要求内容有深度，条例清晰，实用性强。 速查速用。要求步骤简练，清晰易懂。 技术拓展。要求有根有据，证据充实。 那么最好的组织形式应当为： F&amp;Qxxx为什么xxx？xxx是怎样的？解析：………………………… 参考文献： …规范中的内容]]></content>
      <categories>
        <category>感·想</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diary180308]]></title>
    <url>%2F2018%2F03%2F08%2Fdiary20180308%2F</url>
    <content type="text"><![CDATA[下午4点科教南楼开班会。 18:58:49 春招临近，心情复杂。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[突然的自我]]></title>
    <url>%2F2018%2F03%2F07%2Fdiary20180307%2F</url>
    <content type="text"><![CDATA[在网上看到她上课的样子，瞬间捂住嘴，泪流满面，太美了，太美了…… 3:04:22 熬夜写论文。其实明天只是前期检查，没必要这么紧张啊。 11:07:23 吃完午饭。这几天天天吃面。 13:16:54 持续写论文（调研报告）…… 16:30:23 两点半到三点半去升华楼504前期调查。老师们啰嗦了半天，略微检查了报告。回来看齐木楠雄~ 19:35:29 看数据结构。 21:15:00 Frank M.Carrano写的《数据结构与算法分析 Java语言描述》（第2版）真乃书中上品！！！ 22:38:06 最近每天晚上大概都是这样：]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chrome生产力up！]]></title>
    <url>%2F2018%2F03%2F06%2Fdiary20180306%2F</url>
    <content type="text"><![CDATA[11:18:46 用了chrome的beta版，各种开启GPU加速，各种预测，各种提前加载，各种多线程加载，爽！ 12:44:09 来到图书馆。 14:57:06 下了一堆论文。 15:14:04 修改了博客中时间标记的样式。 20:08:05 把翻译编辑完毕。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[真·看戏]]></title>
    <url>%2F2018%2F03%2F05%2Fdiary20180305%2F</url>
    <content type="text"><![CDATA[12:12:29 早上搞了个大乌龙。本来去图书馆借书，结果书包竟然落在小吃店！到了图书馆进了门才发现不太对，一摸背后没东西。。。好在借到好书，借回来看。 下午找老师聊了毕设。难搞。 今天三五，看到很多车上印着雷锋。 23:29:07 10点左右略感无聊，与胡出去逛，去到肯德基点了两杯咖啡（买一送一券）和一份奥尔良烤翅（也是券）。店员提醒说旁边有争端，心想正好可以看戏。坐在角落靠窗位置听了一会，没想到酷似韩红的女主坐了过来，原来是看上了胡的美颜，说起来龙去脉，添油加醋，很不可信。我和胡面对面喝着咖啡就听着，警察和另外的当事人情侣待在旁边。那老师的声音跟我还有点像。听了一会见胡烦了，故离开。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搬家（下）]]></title>
    <url>%2F2018%2F03%2F04%2Fdiary20180304%2F</url>
    <content type="text"><![CDATA[中午正式从湘浦退房搬离。 15:07:47 在凯李咖啡写论文中。 20:52:48 下午到图书馆借了分布式相关的书，路上觉得天气渐阴就回家了。一个小时后瓢泼大雨。 23:42:25 在家写了几个小时代码，惊奇的发现时间过得挺慢。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搬家（上）]]></title>
    <url>%2F2018%2F03%2F03%2Fdiary20180303%2F</url>
    <content type="text"><![CDATA[15:23:34 在宾馆呆到现在。网速正比于生活质量呀。 15:51:30 来到凯李咖啡。 17:09:20 正在写调研报告。比想象中好写一些。 18:26:58 有必要把各种树重新实现一遍。 晚上把所有东西搬到新家。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用元算法记录]]></title>
    <url>%2F2018%2F03%2F02%2Fnote-algorithm-tricks%2F</url>
    <content type="text"><![CDATA[位运算 二进制 十进制 位运算 10000…0（1后面n个0） 2n 1&lt;&lt;n 1111…1（n个1） 2n-1 1&lt;&lt;n-1 数据类型取值 数据类型 取值范围 备注 无符号int 0~232-1 32个1 有符号int -231~231-1 最高位符号位，1表负。负数补码为除符号位取反+1。最小为32个1，1个符号31个值，则为2？？]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重任务]]></title>
    <url>%2F2018%2F03%2F02%2Fdiary20180302%2F</url>
    <content type="text"><![CDATA[9:55:15 来到库克咖啡，身心愉快。 事情有点多。 毕设 安装aspen 调研报告 数据结构刷题 并发项目 淘淘商城项目 jvm视频 10:56:58 感受到上午，下午，晚上心境的不同。上午总想着玩，就算是强制自己学东西也容易分心；下午自动认真起来；下午4点一直到睡前注意力都会自动集中。由此看来，上午适合学新知识，下午适合复习和钻研。 13:17:15 开始学习谷歌ai公开课，Jupyter ，Colaboratory,真乃神器也！ 16:35:03 终于不怕递归了！之前做递归的算法出错率居高不下，今天看了这个回答，豁然开朗！迅速刷起牛客递归算法题，百战百胜！ 18:08:30 来套图书馆咖啡店。还是抑制不住欣喜呀！ 23:10:00 计划从湘浦家庭旅馆搬到温馨旅馆。网速即是生活质量啊。 2:04:14 核查了学分，一分不差，虚惊一场。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[上午，上午]]></title>
    <url>%2F2018%2F03%2F01%2Fdiary20180301%2F</url>
    <content type="text"><![CDATA[早晨起床竟然有些头痛，起来之后收拾屋子，把桌椅换了位置。 上午的时间一直不能有效利用，要改。 14:44:40 来到凯李咖啡，网络修好了。 17:21:04 正在尝试把学长的pso算法用java重新实现以便理解。 19:51:07 下载aspen中。真大，18G。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[资源收藏/书单记录]]></title>
    <url>%2F2018%2F02%2F28%2Fthought-favorite%2F</url>
    <content type="text"><![CDATA[读来感觉不错的书数据结构与算法分析 java语言描述 Frank M.Carrano 著 清华大学出版社 ISBN：9787302162698 深入理解计算机系统 第三版 ISBN：9787111544937 实战Java虚拟机——JVM故障诊断与性能优化 编写高质量代码：改善Java程序的151个建议 Maven权威指南 分布式架构大型分布式网站架构设计与实践 大型网站系统与JAVA中间件实践 深入分布式缓存 从原理到实践 分布式Java应用基础与实践 网络教程动手学深度学习 http://zh.gluon.ai 谷歌官方 TensorFlow 速成课 https://developers.google.cn/machine-learning/crash-course 微软人工智能课 https://academy.microsoft.com/en-us/professional-program/tracks/artificial-intelligence/ 汇编语言 https://www.youtube.com/watch?v=wLXIWKUWpSs 多媒体工具图片压缩网站 https://tinypng.com 谷歌Colaboratory https://colab.research.google.com 向前辈学习http://blog.fens.me java http://www.hollischuang.com/ 程序员面试要准备哪些方面的内容？ - ninechapter的回答 - 知乎https://www.zhihu.com/question/38255755/answer/101708666 http://zephray.cnvintage.org/ 下载资源上海研发公共服务平台 中西文科技文献服务平台 http://lib.sstir.cn 图书馆参考联盟 http://www.ucdrs.superlib.net 科技前沿实效云用户组 http://www.ecug.org 小众软件任务栏网速/内存/CPU XMeters 任务栏天气 墨迹天气 全局快捷 wox 代码工具http://www.autojcode.com 文献网站JSTOR，ELSEVIER，springer 轮询网站Stackoverflow Wikipedia]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>资源收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构计算]]></title>
    <url>%2F2018%2F02%2F28%2Fnote-adt-cal%2F</url>
    <content type="text"><![CDATA[T(n)与O(n) 名称 含义 n 问题规模 T(n) 时间复杂度 f(n) 基本运算的频度 O(n) 时间复杂度的数量级 三者的关系：T(n)=O(f(n)) 不等式T(n)&lt;=cO(n) c为常数 计算时间复杂度设运行次数为t，判断终止条件。比如 12345678void fun(int n)&#123; int i=1; while(i&lt;=n) &#123; i=i*2; &#125;&#125; 设执行次数为t，则终止条件为 t^2=n，则t=log2n。时间复杂度为O(log2n)]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月末]]></title>
    <url>%2F2018%2F02%2F28%2Fdiary20180228%2F</url>
    <content type="text"><![CDATA[10:54:00 一个小时之前来到库克咖啡。重装微软的安卓应用，终于能接受一些了。continue的体验很不错。 16:11:03 今天时间利用的不好。 21:10:47 把递归地遍历二叉树看成遍地二叉树]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次与翔少的邮件交流]]></title>
    <url>%2F2018%2F02%2F27%2Fthought-study-linhaoxiang%2F</url>
    <content type="text"><![CDATA[在17年年底给翔少发了一封邮件，意外地收到很认真的回复，很有收获，在此保存。 Re: 十分感谢！ 发件人：linhaoxiang32 &#x6c;&#105;&#x6e;&#x68;&#x61;&#x6f;&#120;&#105;&#x61;&#110;&#x67;&#51;&#x32;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;时 间：2017年12月28日(星期四) 凌晨1:20 纯文本 |收件人：李斌 &#49;&#49;&#48;&#50;&#49;&#x30;&#57;&#x31;&#x30;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;标记：已将此邮件标记为星标邮件。 取消星标 嗯可以的 他们要是有问题也欢迎随时交流 在 2017年12月27日 下午8:47，李斌 &#49;&#49;&#x30;&#50;&#49;&#48;&#x39;&#49;&#48;&#x30;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;写道： Hi 翔总:邮件已读完，加上今天看了你在知乎上的一些回答，在学习方向/方法上确有恍然大悟之感，我可能就属于跳过基础，直接学框架的这类，结果经常遇到学习瓶颈。今后应再夯实基础；且须多多经历，结合实际才是。我可以把它分享给同学吗？之前不少学弟还向我请教问题，我觉得你说的才更深刻。再次感谢，确实受益颇多！待我有所进步时再向你请教！ 李斌 —原始邮件—发件人: “Haoxiang Lin”&#108;&#x69;&#x6e;&#104;&#97;&#111;&#x78;&#x69;&#x61;&#x6e;&#x67;&#51;&#x32;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;发送时间: 2017年12月27日 20:21:26收件人: “李斌”&#108;&#105;&#98;&#x69;&#x6e;&#119;&#111;&#114;&#x6b;&#x73;&#x70;&#x61;&#99;&#101;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;;主题: Re: 李斌请教问题 Hi 李斌： 蓝杰的简历应该是好几年前的了吧=。= 第一个问题，我觉得各个方向的基础是相同的，都是计算机的基础知识，算法，操作系统，计算机网络，编译原理。比如你说的刷算法的问题，有些算法题确实会一段时间不刷会忘记，但是如果你把比如算法导论给学清楚了，那应该也很容易就可以手推出来。比如KMP，你可能一段时间不写就会忘了怎么写，但是理解之后自己也可以手推出来。从科班的角度来说，一般都是要这些基础打好了，然后才是往上拓展方向的问题，先要基础扎实了，然后不管是做基础架构，web前后端，还是机器学习等，都会如鱼得水，会有一种循序渐进的感觉。不然就会很快遇到瓶颈。所以我给学弟学妹学CS的人的建议一般都是打好计算机的基础，而不是一开始就学习什么web框架，前端框架，那样都容易本末倒置。上面说的四门课，每一门课学好了都不容易，比如mit6.828， mit的OS课，想认认真真的学下来，需要耗费大量的精力，但也只有这样学下来了，你才会对计算机操作系统有很深刻的理解，然后你再去学习比如分布式系统，就会理解的很快，也更容易举一反三，这四门课的话，我的理解是，算法数据结构要先学，所有计算机技术都可以抽象成一种算法和数据结构。然后是操作系统和计算机网络，操作系统有助于提高你的代码能力和对系统的理解，计算机网络也是一样，可以试试自己实现一个web sever。编译原理有助于你对程序的理解，虽然现在可能属于屠龙记，但是是一门很有趣的课。 学习英语的问题，这个我也没有刻意的学过，但是多看国外技术文档，多看paper，好像自然就看的快了。CS的一些英语表述都不会很难，一般都能猜出他想要表达的意思。这个可以从多看国外技术文档开始练起。 嗯职场的渠道拓展我还不敢妄谈，就我自己而言，我大学的经历，从最早的在猎豹的实习，那时候其实基础还很不牢固，很多都还不会，但是接触了工业界，然后开始对各种技术自己研究，大概是在大二结束的时候，发现自己基础还不够牢固，很多知识还没有学好，出现了瓶颈，于是大三上学期和下学期都在自己学习CS的基础课，主要就是学MIT的课程还有清华的课程。同时继续自己的实习，了解不同的技术方向，在阿里经历了后端，前端，算法的实习，然后发现自己可能更喜欢做偏向系统方向的东西。同时也开始想读博，然后gap一年，在滴滴研究院，msra，头条lab做infrastructure相关的实习，然后到现在转到了基础架构方向上。各个方向都尝试过了一遍之后才找到更喜欢的方向。对于如何换方向的这个问题，一个是我也有些机缘巧合，另一个就是去找这个方向顶尖的实习岗位，研究院，看看他们的要求，然后一个个去学习一下。对于实习生来说，他们对招你的要求不会太高，一般都会更喜欢基础好的学生，这就是我说的计算机基础好的重要性。很多时候，有可能他们岗位的很多技术要求你不满足，但是你的基础很好，他们还是愿意招你进来当实习生然后培养。 大概就是这样，还有疑问的话欢迎随时交流。 Thanks,Haoxiang 在 2017年12月27日 下午3:09，李斌 &#x6c;&#x69;&#x62;&#105;&#110;&#x77;&#111;&#x72;&#x6b;&#x73;&#112;&#x61;&#x63;&#x65;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;写道： hi翔总: 上次在蓝杰,看到你的简历, 实在望尘莫及.内心挺感慨,想请教些问题;虽然几次谋面,但仍然觉得邮件请教更为妥当.望翔总空闲时对此些问题回复片语,十分感谢. 就我个人体验,算法数据结构/编程语言(编译原理)/分布式存储/web 等方向,我感觉每个方向都不容易精通.常常是这样的情况:例如,刷算法题当时会了,然后搞别的,过后就又丢了算法.如果我也想向基础架构方向发展,这几个方面的依赖关系是怎样的呢?或者说,哪方面最重要;应该多多培养什么意识/能力呢? 如何学习英语? 虽然近期强制自己不看中文教程而看官方文档,但是还是在阅读时感到磕磕绊绊.比如今天在看6.824的lab,感觉云里雾里. 怎样有效/快速的提高英文阅读水平,翔总有经验吗? 如何拓展求职渠道? 在自己的技术水平的每个阶段,怎样增大找到好的offer的机会呢? 大概是这些问题,多谢翔总解答了,抱拳]]></content>
      <categories>
        <category>感·想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gitignore文件速查]]></title>
    <url>%2F2018%2F02%2F27%2Fquick-git-gitignore%2F</url>
    <content type="text"><![CDATA[基于Intellij的python： 123venv/.idea/__pycache__/]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现充第一步]]></title>
    <url>%2F2018%2F02%2F27%2Fdiary20180227%2F</url>
    <content type="text"><![CDATA[爽！ 昨天把备用机“夹”在了门框旁边，充电线不拔下来，当做智能硬件使用。把小娜设置为应用内外都响应声音，晚上一句晚安就能把屏幕把闹钟设定为老式闹钟铃声，直接最大音量，早晨一听就震起来了！ 上午去图书馆借书。考研的数据结构辅导书中有很多例题，应该会有所帮助。 12:16:26 来到库可咖啡。 12:22:15 想到一个邪招。用微软小娜唤起小爱同学，哈哈 16:13:43 论文翻译格式修改完毕。改日发给老师。开始整理简历。 19:01:55 与胡来家润多前吃了黄焖鸡米饭，感觉不错。来到左岸咖啡，我点了一份红酒炖雪梨。]]></content>
  </entry>
  <entry>
    <title><![CDATA[保持早起]]></title>
    <url>%2F2018%2F02%2F26%2Fthought-get-up%2F</url>
    <content type="text"><![CDATA[如何改掉赖床的习惯？ 醒来后的一个小时，思维混乱，只要当天没有任务，身体会不由自主地趋向于躺到10点，晚睡晚起，恶性循环。 事实上，一旦全身只有两足接触地面，就很容易脱离半眠不醒的状态。 目前解决方案：把闹钟放在厕所，起床后逼迫不清醒的自己下床关闹钟。]]></content>
      <categories>
        <category>感·想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一周计划]]></title>
    <url>%2F2018%2F02%2F26%2Fdiary20180226%2F</url>
    <content type="text"><![CDATA[昨天没有写日记。本想今天补上再标注上昨天的时间，但想想还是给自己定下一个标准：对于希望形成习惯的事情，不要设定计划，也不要作假。 今天与老师和学长聊了毕业论文的内容。欣喜地发现需要做的内容确确实实就是我希望在简历中添加的分布式相关的内容；老师和学长也都希望我不要造轮子，而是要有所创新和突破。 心里总是惦记着春招。每天上午的时间实在浪费的可怕，微博一众社交软件真乃时间杀手。微博还是换成国际版比较好。 不能再晚睡晚起。每天从上午10点半到晚上10点半，有10个小时以上的时间可以利用。 本周计划： 日期 计划 周二 把论文翻译格式化，并发送给老师；开始修改简历。根据简历反推下一步计划；迁移为知笔记的内容到博客上 周三 继续把并发项目，在一天之内写完！ 周四 周五 周六 周日]]></content>
      <tags>
        <tag>日·记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用命令速查]]></title>
    <url>%2F2018%2F02%2F25%2Fquick-mysql-command%2F</url>
    <content type="text"><![CDATA[帮助命令首先要活用help命令。 例如，键入help CREATE DATABASE，显示： 12345678910111213141516mysql&gt; help create databaseName: 'CREATE DATABASE'Description:Syntax:CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_nameCREATE DATABASE creates a database with the given name. To use thisstatement, you need the CREATE privilege for the database. CREATESCHEMA is a synonym for CREATE DATABASE.URL: http://dev.mysql.com/doc/refman/5.7/en/create-database.html 注意帮助命令语法：用大括号括起来的是必需内容，用方括号括起来的是可选内容。|表示“或”。 选中/查看数据库相关选中数据库1234USE db1;SELECT COUNT(*) FROM mytable; # selects from db1.mytableUSE db2;SELECT COUNT(*) FROM mytable; # selects from db2.mytable 查看当前选中的数据库1select database(); 查看数据库引擎相关查看支持的引擎1show engines; 查看当前默认的存储引擎1show variables like '%storage_engine%';]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[起床战争]]></title>
    <url>%2F2018%2F02%2F25%2Fdiary20180225%2F</url>
    <content type="text"><![CDATA[昨天晚上玩塞尔达到3点多。垃圾游戏毁我青春，今天把switch还回去，再也不玩了T_T。。 不过本来以为今天肯定起不来了，没想到8点多自己就醒了。 衡中那几年每天听铃声被震起来，实习那几个月每天被闹钟催起来。这些年终于总结出一个事实，那就是，人在起床之后的至少半小时内是混乱的、不理性的、极度趋向于再次睡眠的。此时就需要一个强大而不可抗的力量把他从床上拽起来，并阻止其回到床上。跑操，上班，都是不可抗力；大学以来，尤其是课程签到的不严格，渐渐纵容了赖床因子，独居时如果不及时改正，大把青春就废掉了。 也许设定一些羞耻的、不希望别人听到的、只要一听到不管睡的多死我都会立刻弹起来打起十二分精神的闹钟会比较有效。]]></content>
  </entry>
  <entry>
    <title><![CDATA[粒子群优化(PSO)算法学习笔记]]></title>
    <url>%2F2018%2F02%2F24%2Fnote-pso%2F</url>
    <content type="text"><![CDATA[基本信息PSO：Particle Swarm Optimization，1995 年由 Eberhart 博士和 Kennedy 博士一起提出。 初步形象理解一群鸟儿期望寻找一片玉米地。它们都知道自己距离玉米地的距离，但都不知道确切位置。它们相互传递信息，最终所有的鸟都将知道最近的距离。 精细理解具体到算法中，上述的“鸟”抽象为无质量的例子，仅具有两个属性：位置和速度。每个粒子在搜索空间中搜寻最优解，标记为当前个体的极值，并将其与其他粒子共享，最终找到最优的个体极值作为当前全局最优解，所有粒子根据当前个体极值和当前全局最优解来调整速度和位置。 算法思想步骤如下： 初始化粒子群，包括随机的位置和速度； 评价每个粒子的适应度； 对于每个粒子，将它的适应值和它经历过的最好的位置pbest比较，如果较好，则将其作为当前的最好位置pbest； 对每个粒子，将它的适应值和全局所经历的最好位置gbest的作比较，如果较好，则重新设置gbest（的索引）； 根据公式更新粒子的速度和位置 如果达到条件（通常为足够好的适应值或者达到一个预设最大数Gmax）,终止计算，否则返回2。 公式 vidk+1 = w ∙ vidk + c1 ∙ rand() ∙ ( pid - xid ) + c2 ∙ Rand() ∙ ( pgd - xid ) xidk+1 = xidk + r ∙ vid 参数解释： w : 保持原来速度的系数，所以叫做惯性权重 c1 : 粒子跟踪自己历史最优值的权重系数，它表示粒子自身的认识，所以叫“认知”。通常设置为2。 c2 ：是粒子跟踪群体最优值的权重系数，它表示粒子对整个群体知识的认识，所以叫做“社会知识”，经常叫做“社会”。通常设置为2。 rand() 是[0,1]区间内均匀分布的随机数。 r 是对位置更新的时候，在速度前面加的一个系数，这个系数我们叫做约束因子。通常设置为1。 用自然语言理解公式： 更新后个体速度 = 惯性权重 * 更新前个体速度 + 个体认知系数 * 0到1的随机数 * ( 更新前个体最优位置 - 更新前个体位置 ) + 社会认知系数 * 0到1的随机数 ( 更新前全局最优位置 - 更新前个体位置 ) 更新后个体位置 = 更新前个体位置 + 约束因子 * 更新后个体速度 参数理解惯性权重系数 w 使微粒保持运动的惯性，使其有扩展搜索空间的趋势，有能力探索新的区域。 加速常数c1和c2代表将每个微粒推向pbest和gbest位置的统计加速项的权重。低的值允许微粒在被拉回来之前可以在目标区域外徘徊，而高的值导致微粒突然的冲向或者越过目标区域。 如果没有第一部分，即w = 0，则速度只取决于微粒当前的位置和它们历史最好位置pbest和gbest，速度本身没有记忆性。假设一个微粒位于全局最好位置，它将保持静止。而其它微粒则飞向它本身最好位置pbest和全局最好位置gbest的加权中心。在这种条件下，微粒群将统计的收缩到当前的全局最好位置，更象一个局部算法。 如果没有后两部分，即c1 = c2 = 0，微粒将一直以当前的速度飞行，直到到达边界。由于它只能搜索有限的区域，将很难找到好的解。 在加上第一部分后，微粒有扩展搜索空间的趋势，即第一部分有全局搜索的能力。这也使得w的作用为针对不同的搜索问题，调整算法全局和局部搜索能力的平衡。 如果没有第二部分，即c1 = 0，则微粒没有认知能力，也就是“只有社会（social-only）”的模型。在微粒的相互作用下，有能力到达新的搜索空间。它的收敛速度比标准版本更快，但是对复杂问题，比标准版本更容易陷入局部优值点。 如果没有第三部分，即c2 = 0，则微粒之间没有社会信息共享，也就是“只有认知（cognition-only）”的模型。因为个体间没有交互，一个规模为m的群体等价于m个单个微粒的运行。因而得到解的几率非常小。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven常用模板与设置]]></title>
    <url>%2F2018%2F02%2F24%2Fquick-maven-config%2F</url>
    <content type="text"><![CDATA[快速配置文件夹初始化123456789└── $&#123;basedir&#125; └── src ├── main │ ├── java │ └── resources ├── target │ ├── classes │ └── xxx.jar └── test 国内镜像123456789101112131415161718192021222324252627282930313233343536373839&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库在中国的镜像 --&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 空项目配置文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; xxx &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;xxx&lt;/version&gt; &lt;configuration&gt; xxx &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 常用配置属性1234567&lt;properties&gt; &lt;!-- 文件拷贝时的编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- 编译时的编码 --&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;&lt;/properties&gt; 常用插件及配置1234567891011121314151617181920212223242526272829303132333435&lt;build&gt;&lt;!-- https://maven.apache.org/plugins/ --&gt; &lt;plugins&gt; &lt;!-- 编译选项 --&gt; &lt;!-- https://maven.apache.org/plugins/maven-compiler-plugin/index.html --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 跳过测试 --&gt; &lt;!-- http://maven.apache.org/surefire/maven-surefire-plugin/ --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.21.0&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- tomcat --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/$&#123;project.artifactId&#125;&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 问题解答Q：maven-compiler-plugin插件中，source和target的含义？A： 都是javac的命令。-source指定语言的版本，-target指定jvm的版本。比如，你已经装了java 9，而想用java 8的语言特性，编译为java 7支持的字节码，即可设置为 12345678&lt;project&gt; [...] &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; [...]&lt;/project&gt; 或者 12345678910111213141516171819&lt;project&gt; [...] &lt;build&gt; [...] &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; [...] &lt;/build&gt; [...]&lt;/project&gt; Q：几种关于编码的命令A： project.reporting.outputEncoding：reporting做“数据传送”解。用于某些数据传送插件在传输数据的编码 project.build.sourceEncoding：代码文件的编码 Q：scope有哪几种，分别有什么作用？A： provided：某些依赖只参与编译，不参与打包，如Tomcat自带了Servlet与JSP的包，就可以设置为provided。 runtime：某些依赖这是运行时需要，无需参与编译。如JSTL的jar包。 常用插件及命令Maven Help用于输出插件信息，包括： name Description Group Id Artifact Id Version Goal Prefix goals … 例如，输出Maven Help插件的信息 12345678910111213141516171819202122232425262728293031323334$ mvn help:describe -Dplugin=help...Name: Apache Maven Help PluginDescription: The Maven Help plugin provides goals aimed at helping to make sense out of the build environment. It includes the ability to view the effective POM and settings files, after inheritance and active profiles have been applied, as well as a describe a particular plugin goal to give usage information.Group Id: org.apache.maven.pluginsArtifact Id: maven-help-pluginVersion: 3.1.0Goal Prefix: helpThis plugin has 8 goals:help:active-profiles Description: Displays a list of the profiles which are currently active for this build.help:all-profiles Description: Displays a list of available profiles under the current project. Note: it will list all profiles for a project. If a profile comes up with a status inactive then there might be a need to set profile activation switches/property.help:describe Description: Displays a list of the attributes for a Maven Plugin and/or goals (aka Mojo - Maven plain Old Java Object)....For more information, run 'mvn help:describe [...] -Ddetail'...]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven常用依赖快捷查询]]></title>
    <url>%2F2018%2F02%2F24%2Fquick-maven-dependency%2F</url>
    <content type="text"><![CDATA[servlet 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; mysql/jdbc 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt;&lt;/dependency&gt; JUnit4 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; slf4j-log4j12 123456&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加油干~]]></title>
    <url>%2F2018%2F02%2F24%2Fdiary20180224%2F</url>
    <content type="text"><![CDATA[果然长沙是冰冷的要命！回来对比之后才深有感触——还是需要开空调度日。 想起高中刚毕业，李沙请我吃自助餐。当时我是从来没吃过那么高大上的东西，全程不知所措，想来真是尴尬……大学毕业，却也怀念那时的心境。 下午看下长沙的几个咖啡店，开始学习啦。 上午到升华公寓士心跆拳道馆，发现早已楼空。加了牌子上的微信，才知已搬到步步高二楼。故往，场地不错，还有实惠的学期卡。交100元计划体验两次。 来到库克咖啡，开始下午的工作。 库克咖啡5点半就关门了.来到凯李，老板真是热情，给了两包冲水饮品.qq上看到老师的通知.论文要加紧了.]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回校，困倦，火锅，心情不错]]></title>
    <url>%2F2018%2F02%2F23%2Fdiary20180223%2F</url>
    <content type="text"><![CDATA[清晨5点半到达火车站，遇上个好司机，早早到校。收拾屋子，小睡一会，赶在10点半看了红海行动，尺度真tm大呀。看完回来继续收拾屋子，下午打了最后一针疫苗，去通程广场麦当劳与胡回合。一时兴起吃了人均100多块的火锅，吃的真爽，花的真心疼。 今天下午4点多还没接胡的时候，就已经感受到困倦。想来昨天在火车上睡了整整一个下午，加上昨晚的几个小时，竟然还没睡够，不连续的浅睡眠真是不划算；10点多更是困倦不堪，本想早睡，帮白挑笔记本挑了半天，到现在熬到11点半。 好在心情尚佳。便签上还有不少尚待解决的琐事，明天一天抽时间搞定。 长沙的天气非常好，之后几天会更好，十分开心。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[离家]]></title>
    <url>%2F2018%2F02%2F22%2Fdiary20180222%2F</url>
    <content type="text"><![CDATA[昨晚在医院过了一夜，今早回家，即将回校。临别前奶奶给我塞了酸奶和两根黄瓜，让我路上啃。陪我下楼买烧饼，还没有做好，遂别。到楼下给妈打电话下楼开大门，到家收拾东西。这次回家，感受不太一样。家人和朋友，好像都比以往亲切好多。又是离家，祝我好运。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[家人]]></title>
    <url>%2F2018%2F02%2F21%2Fdiary20180221%2F</url>
    <content type="text"><![CDATA[补昨日记: 中午去奶奶那边，去的时候其实大表妈和二表妈在那里(并不认识)，一起包饺子，吃饺子。饭后，老姑父展示了他感人的情商——他在里屋跟两个表妈聊天，悦悦走过去问什么时候买书包，张口就回了一句“等你表妈走了再带你去。”当时正在和妈，奶奶，老姑在外边闲聊，此时我看到他们的表情出奇的一致。两秒不到，两个表妈便穿衣走出卧室，准备离开。奶奶忙拉回来再小叙几句，妈和老姑仍然忍不住嫌弃的表情。把客人送走之后，正值两点一刻。老姑父突然来一句，“嫂子晚上留下来吃啊？”我妈都不知道是笑还是气。以上是小事。老姑父的品行在十年前就已经暴露无遗，目中无人，不敬老人，唯钱是图，老姑早就难以忍耐。也许，老姑可能也会经历与爸相似的命运；悦悦可能会经历与我相似的命运。 接下来才是大事。奶奶喂爷爷中药，不知为何进食的软管堵塞，奶奶，爸妈，我，九牛二虎之力无果，空针管打气打水纹丝不动，用金属导丝捅，如遇墙壁。奶奶十分自责，发泄了几句，我和妈说着好话。待爸回家，一家人商量着把爷爷送到医院，看情况是重新下管还是用其他办法。催悦悦睡觉，清理屋子通道，联系医生，叫救护车。所有人一起抬着爷爷进电梯，我和老姑父把爷爷抬上救护车，到中医院拍了CT。最后，我和爸留下，其他人回家；睡到半夜（凌晨？），奶奶来了，爸去上班。九点半左右，妈来医院，我回家休息。 奶奶可能太过紧张。实际上情况并不糟糕，爷爷并不是因为病情而转移，而仅仅是塑胶管堵塞；而且正好也可以在医院给爷爷输液，治疗一下最近退不下的发烧。 抬爷爷进电梯时，大家很着急，大家抬的很用力，大家抱的很紧。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[健康tips]]></title>
    <url>%2F2018%2F02%2F20%2Fdiary20180220%2F</url>
    <content type="text"><![CDATA[晨记: 时常口感舌燥.奶奶说的没错,多喝水呀!早起不仅仅会让精神更清晰,更是为了能吃早餐.吃罢早餐,中午才不会过于饥饿,不至于狂长肉…]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[做自己的教官]]></title>
    <url>%2F2018%2F02%2F18%2Fdiary20180219%2F</url>
    <content type="text"><![CDATA[晨记： 已不知多少次，梦中闯下大祸，惊醒后发现并非真实，心中不由得暗暗长吁一口气…… 昨夜梦回高中课堂，老庞讲数学课（几何），我借找老师之名到室外上体育课；操场是小学样子的，却看到了胡伟治一起上课；看到某个不听话的学生被军官狠训，我偷偷穿上军官的衣服，免遭一劫；直到听到下课铃声，我默默脱下军服，正想着如何向老师解释，突然惊醒。刚刚才意识到，这铃声可能就是我昨天设置的闹铃！原来现实世界真的可以影响梦境的~ 正犹豫要不要起床，突然像教官一样把自己被子掀开。是个好办法！迷糊的大脑逐渐就清醒了。新的一天开始~ 做自己的教官吧！ 晚记: 下午去奶奶家，姑父依然颐指气使，唯钱是图。几句嘲讽老姑的话让奶奶和老姑气不打一处来，老妈更是以牙还牙，姑父仍然看着电视嘴里不停。妈是女强人，看不惯老姑的嘴脸，几个人虽然挤在不到十平米的小屋子里，刚刚也都从饭桌上下来，现在却几乎要围着电视大吵起来。想来姑父这让人反感的说辞也保持了快十年了，每年回家都会闹些不愉快，很不愉快的不愉快。我去安慰老姑。老姑一说就停不下来，直至泣不成声。我握着她的手，一遍遍的说着情况没有那么糟，也尝试让她换个思路想想，让他们从破裂的边缘回来。悦悦玩了会手机，也受不了他爸爸的粗鲁，一直找我抱。我让老姑从内心坚强起来，勇敢的面对他，用温柔代替对抗，尝试以柔克刚，让老姑父转变过来。老姑不像妈妈那般斩钉截铁，难以用嗓门和威胁来为自己争取利益，也许这种方式能让她好受些吧。老姑很激动，很欣喜，不住的谢我，我心疼无比。 晚上回家，跟妈谈起前两天的争吵。想来我也是有些可笑，都二十几岁的人了还有青春期的叛逆。老妈的沉默十分有力量，接着开始一如预期的讲道理。我以前想，妈实在话太多了，有时几个是或否足以说明的问题，非要一遍遍重复，我又不能反驳更不能离开，只能边听边点头，边听边同意地笑笑，然后原地挣扎几分钟等她说完离开。今天聊了几句，突然感觉，也许这就是母亲，注定不能像父子般干脆利落，她表达关心的方式就是一遍遍的说啊说啊，也不管你听得进去听不进去。也许这就是最好的状态，就算是我的生母，甚至都可能不会比这让我轻松，也许我们的母子关系已经要比其他家庭好得多——我确实有些身在福中不知福了。]]></content>
      <categories>
        <category>日·记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[鞭打，或者追逐]]></title>
    <url>%2F2018%2F02%2F18%2Fdiary20180218%2F</url>
    <content type="text"><![CDATA[自从小米的offer确认，至今天即将又三个月过去。没有了危机感，身体就开始懈怠。好像从12月份开始，作息变得越来越不规律：起初，每天最晚最晚不过1点也睡了，直至过年之前，跟阿胡去了一次网吧，作息就再也没调整过来；睡眠倒是一直很足。那天被野猫给咬了，之后每隔几天去打一次疫苗，每打完一次就困得不行，加上长沙天寒地冻，屋内不开电暖冰冷如狗，早晨就更不愿意起，导致一个星期的昼夜颠倒。本以为无碍，每天仍然是8小时代码或娱乐，不曾想由于没了时间参照，不知何时食寝。好在2月10号回家，总算把作息调整回来。真是黑暗的一周，或吃或睡全凭直觉，每天天蒙蒙亮却困意十足，睁眼已经傍晚，实在是太不爽。 在家稍微好些，但也并非无愧。肚子上的肉越来越多，脸也开始臃肿（恐怖！），起床或睡觉都是要挣扎的事情。这几天跟政，晖，阳，放，朱，程吃饭玩耍，发现不玩游戏就是缺乏共同语言啊。初七就回校了，不希望再回到不自律的生活。 时常回想起高中生活。三年，尤其是最后一年，几乎每天中午拖着疲惫的身子从宿舍跑到教学楼，都在默默问天：这样的日子什么时候才能到头？岂不知那可能是人生最健康，最规律的日子。知乎上有个问题，人是怎么废掉的？没有危机感，没有输出。 说好的每天写日记，更多地被别的事情占用。博客也是输出，输出让我清醒。 坚持吧！没有人看着自己，就只能自己命令自己！无愧于心，假如我的身边有朋友，有父母，有同学，在看着我，我会做什么，不会做什么？10分钟，10小时，10年之后，我会怎样看待当前的事情？铭记！ 晚记：下午与程聊天，听她说了半天苦追小哥哥的心路历程，哈哈。晚上与程，宁，阳晖，朱，去北孔雀城广场放孔明灯，天气很冷，心情很好。姐和妈去了天津，晚上家中只有一人，甚爽！]]></content>
      <categories>
        <category>日·记</category>
      </categories>
      <tags>
        <tag>生活方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统网络相关记录]]></title>
    <url>%2F2018%2F01%2F31%2Fquick-linux-troubleshot%2F</url>
    <content type="text"><![CDATA[通用apt-getE: Unable to locate package build-sessential更新源： 1sudo apt-get update E: Could not get lock12ps aux | grep aptkill -9 processnumber 参考：https://askubuntu.com/a/315791 分版本问题CentOS 7安装系统之后无法访问网络修改配置文件 1vi /etc/sysconfig/netword-scripts/ifcfg-ens33 将ONBOOT改为yes。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统常用命令汇总]]></title>
    <url>%2F2018%2F01%2F31%2Fquick-linux-command%2F</url>
    <content type="text"><![CDATA[环境变量查看单个环境变量： echo $PATH查看所有环境变量： env mount命令格式1mount [-t vfstype][-o options] device dir 命令含义设备device的文件系统是-t,此命令将以-o的挂载方式将其挂载在dir挂载点上。 参数解释 -t vfstype指定文件系统类型，一般不同指定。一般不必指定，命令会自动选择。 光盘或光盘镜像：iso9660 DOS fat16文件系统：msdos Windows 9x fat32文件系统：vfat Windows NT ntfs文件系统：ntfs Mount Windows文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs -o options描述挂载方式。 loop：用来把一个文件当成硬盘分区挂接上系统 ro：采用只读方式挂接设备 rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集 device要挂载的设备 dir设备在系统上的挂载点(mount point) less]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记 - 排序篇]]></title>
    <url>%2F2018%2F01%2F30%2Fnote-algorithm-sorting%2F</url>
    <content type="text"><![CDATA[冒泡排序原理： 比较相邻的元素，如果第一个比第二个大，那么就交换。 对每一对相邻元素都重复第1步，从开始到结尾。这样一来，最后的元素会变成最大的元素。 针对所有元素重复进行1和2，除了最后一个。 持续对越来越少的元素重复以上步骤，直到没有任何一对数字需要比较。 针对以上步骤写伪代码： 第一步 12if (array[i] &gt; array[i+1]) swap(array[i], array[i+1]) 第二步 1234for(i from 0 to length-1)&#123; if (array[i] &gt; array[i+1]) swap(array[i], array[i+1])&#125; 第三、四步 问题在于“最后一个”如何定义。由于已遍历次数=末端已经排序的元素数量，故末端除去已经排序好的元素的长度为数组长度-末端已经排序的元素数量，此时最后一个元素的下标应为数组长度-末端已经排序的元素数量-1=数组长度-1-遍历次数=数组长度-1-（当前遍历次数-1）=数组长度-当前遍历次数，而当前遍历次数=外循环变量+1。反应到代码中遍历的终点，应当是数组长度-外循环变量-1。 java实现： 1234567891011public static void bubbleSort(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = i; j &lt; array.length - i - 1; j++) &#123; if (array[j] &gt; array[j+1]) &#123; int tmp = array[j+1]; array[j+1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 时间复杂度：O(n2) 空间复杂度：O(1) 快速排序快速排序是基于冒泡排序的改进。比较和移动是从两端到中间进行。 原理 从数列中挑一个元素，称为“基准”(pivot), 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 代码实现版本1先移动i，并对范围进行严格限制。 12345678910111213141516171819202122232425262728293031323334353637383940414243public void quickSort(int[] array) &#123; quickSort(array, 0, array.length - 1, 0);&#125;/** * 每次操作的结果：左边的值&lt;=基准值&lt;=右边的值，也就是将基准值归位 * * @param array * @param lo * @param hi * @param pivot */private void quickSort(int array[], int lo, int hi, int pivot) &#123; if (lo &gt;= hi) &#123; return; &#125; int i = lo; int j = hi; //4.重复执行，直到i和j相遇并交错。此时j在i的紧邻左边的位置。 while (i &lt; j) &#123; //1.在i不超过j的情况下，把i移动到从左到右第一个比基准值大的位置。 while ((i &lt;= j) &amp;&amp; (array[i] &lt;= array[pivot])) &#123;//必须把范围判断放在前面 i++; &#125; //2.在i不超过j的情况下，把j移动到从右到左第一个比基准值小的位置。 while ((i &lt;= j) &amp;&amp; (array[j] &gt;= array[pivot])) &#123; j--; &#125; //3.当i在j左侧时，交换i，j元素位置。当i在j右侧时，说明二者交错，j对应的元素更小，需要与pivot交换。 if (i &lt; j) &#123; int tmp1 = array[i]; array[i] = array[j]; array[j] = tmp1; &#125; &#125; //5.基准值是比较对象，位置不会随比较而变化，故需 int tmp2 = array[lo]; array[lo] = array[j]; array[j] = tmp2; quickSort(array, lo, j - 1, lo); quickSort(array, j + 1, hi, j + 1);//必须是j+1，否则如果是顺序序列，会无限循环&#125; 版本2先移动j，可以简化范围检查。 123456789101112131415161718192021222324252627282930313233343536373839404142public void quickSort(int[] array) &#123; quickSort(array, 0, array.length - 1, 0);&#125;/** * 每次操作的结果：左边的值&lt;=基准值&lt;=右边的值，也就是将基准值归位 * * @param array * @param lo * @param hi * @param pivot */private void quickSort(int array[], int lo, int hi, int pivot) &#123; if (lo &gt;= hi) &#123; return; &#125; int i = lo; int j = hi; //4.重复执行，直到i和j相遇并交错。此时j在i的左边一个。 while (i &lt; j) &#123; //1.把j移动到从右到左第一个比基准值小的位置。 while ((i &lt; j) &amp;&amp; (array[j] &gt;= array[pivot])) &#123; j--; &#125; //2.把i移动到从左到右第一个比基准值大的位置。 while ((i &lt; j) &amp;&amp; (array[i] &lt;= array[pivot])) &#123;//必须把范围判断放在前面 i++; &#125; //此时j一定不在i的右边，并且j对应的值比i小，所以无需判断i与j的关系 int tmp1 = array[i]; array[i] = array[j]; array[j] = tmp1; &#125; //5.基准值是比较对象，位置不会随比较而变化，故需 int tmp2 = array[lo]; array[lo] = array[j]; array[j] = tmp2; quickSort(array, lo, j - 1, lo); quickSort(array, j + 1, hi, j + 1);//必须是j+1，否则如果是顺序序列，会无限循环&#125; 归并排序代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void mergeSort(int[] array) &#123; mergeSort(array,0,array.length-1);&#125;public void mergeSort(int[] array, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; int midLeft = (lo + hi) / 2; mergeSort(array, lo, midLeft); mergeSort(array, midLeft + 1, hi); merge(array, lo, midLeft, hi); //先分割，再归并&#125;private void merge(int[] array, int lo, int midLeft, int hi) &#123; int[] newArray = new int[hi - lo + 1]; int i = lo; int j = midLeft + 1; int newArrayPointer = 0; while (i &lt;= midLeft &amp;&amp; j &lt;= hi) &#123; if (array[i] &gt; array[j]) &#123; newArray[newArrayPointer] = array[j]; newArrayPointer++; j++; &#125; else if (array[i] &lt;= array[j]) &#123; newArray[newArrayPointer] = array[i]; newArrayPointer++; i++; &#125; &#125; while (i &lt;= midLeft) &#123; newArray[newArrayPointer] = array[i]; newArrayPointer++; i++; &#125; while (j &lt;= hi) &#123; newArray[newArrayPointer] = array[j]; newArrayPointer++; j++; &#125; newArrayPointer = 0; for (int k = lo; k &lt;= hi; k++) &#123; array[k] = newArray[newArrayPointer]; newArrayPointer++; &#125;&#125;]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英文翻译要点总结]]></title>
    <url>%2F2018%2F01%2F28%2Fnote-english-translate%2F</url>
    <content type="text"><![CDATA[英译汉时的要点 长句分割为短句，大量增加标点符号 大量添加动词 适当省略连词。如省略because等，并调整前后语序。 不翻译过渡词语，如keep，give，allow等。 动词意味的名词翻译为动词。如The sight and sound of our jet planes fitted me with special longing.翻译为：看到我们的喷气式飞机，听见隆隆的声音，令我特别神往。 增加评论性词汇，增加感情。比如：比较，多么 定语从句翻译：定语从句在8个单词以内的时候定语前置，8个单词以上的时候后置。 适当更换主动被动的关系。]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自律使我自由]]></title>
    <url>%2F2018%2F01%2F26%2Fthought-self-discipline%2F</url>
    <content type="text"><![CDATA[常听音乐 醒来后立刻坐起，赖床的代价无比巨大。尝试恐惧赖床。 每天适当护肤。热敷面部，洗净。 饭后刷牙。 尝试恐惧甜食。 视野内不可以出现未洗的袜子或内衣。 每天写下日记，为自己的生活打log。日记里要有自拍，记录生活状态。 每天要出汗。 睡前在电水壶中盛满水，方便晨起洗漱。 用自定义铃声做闹钟。内容为录音，自己叫醒自己。 睡前手机放远。]]></content>
      <categories>
        <category>感·想</category>
      </categories>
      <tags>
        <tag>生活方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机英语单词短语总结]]></title>
    <url>%2F2018%2F01%2F25%2Fnote-english-study%2F</url>
    <content type="text"><![CDATA[有些单词，即便看懂，也不太容易将上下文联系起来，导致整句难以理解。这里总结一些短语的翻译技巧，帮助提高英文阅读能力。 单词/短语 翻译 and 映射为其前面名词对应的动词。如it is A，and B。译为：它是A，是B。 that 在定语从句中，that翻译为“该”，也就是重复一次主语。 to 以，来 a set of 一组 take care of 负责 failure 故障 enable 可以实现 in terms of 在…方面，以…措辞 a variety of 各种 are drawn from 都来自 furthermore 此外 to and from 作为输入输出 identity 一致性，恒等式 add together 累加 be instantiated with… 用…实例化 populate the bean 填充bean underlying 基础的，底层的 toggle 切换 ascending 升序的 nesting 嵌套 scheme 计划，方案 on-demand 随需应变的，请求式 locale 语言环境。如EN_US in case of 如果 scenario 场景；脚本 arbitrary 任意的 propagate 传播，蔓延 rapid coding 快速编码 delegation 委托 confront 面对 outline 概述，轮廓 dedicated 专用的 architectural 建筑上，架构上 contrast 对比 In contrast to 与…对比 layer 层次 tier 层级 clean separation of tiers 清晰的分级 integrate 整合，集成 know-how （传授的）技术 leverage 利用 at your fingertips 唾手可得 Regarding… 关于… out to lunch 神志不清的 resolve 解析 validation 校验 escape value 转义值 functionality 功能 evaluation 评估 corresponding 相应的 augment 增大 facilities 机制，属性 NUMA 非一致性内存访问 switched Ethernet 交换式以太网 dual-processor 双处理器 considerably 相当，远远 in-house 内部的 idle 闲置 Periodically 周期性地 region 区域 forward 转送，运寄 encountered 遭遇到的 conduit 导管，渠道 increamentally 逐渐地 eligible 合适的，有资格的 resilient 可恢复的，有弹性的 semantics 语义学 deterministic 确定性的，命运注定的]]></content>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web 回顾与总结]]></title>
    <url>%2F2018%2F01%2F24%2Fnote-javaweb%2F</url>
    <content type="text"><![CDATA[JSP JSP规范 JavaServer Pages (JSP) Specification, Version 2.2,包含脚本规范,标签规范等 Servlet规范Servlet API Specification, Version 3.0,包含web应用目录结构和部署,url映射,web.xml(容器描述符)语法等 TomcatCATALINA_HOME : tomcat安装根目录CATALINA_BASE : 如果存在多个tomcat实例,那么用此代表每个实例各自的根目录.没有多个实例的话,与CATALINA_HOME相同. 只有重启tomcat,设置文件才能生效. web应用(Web ARchive,WAR file)部署结构参考自tomcat7介绍 document root : 根目录,放置HTML文件和JSP页面,来组成用户界面context path : 管理员分配的路径,映射为document路径.例如,如果conext path被分配为/catalog,那么一个到/catalog/index.html的请求将被映射至document root/index.html 标准目录结构 CATALINA_HOME/lib所有web应用+tomcat共享的jar文件都放这.是JDBC驱动放置的好地方. /*.html,*.jsp等浏览器可见文件(如css,js,图片文件等).这些文件或者分类放置,或者统一放在根目录下. /WEB-INF/web.xml部署描述符 /WEB-INF/classes/ /WEB-INF/lib/ 1234567CATALINA_HOME├─lib└─webapps └─root └─WEB-INF ├─classes └─lib Servlet参照Servlet规范,将重要概念做以下总结. Servlet接口开发者一般通过继承HttpServlet来实现自己的Servlet.目前有GenericServlet和HttpServlet实现了Servlet接口. 请求的处理方法Servlet接口定义了service方法.请求到达,则servlet容器将此请求路由到某个servlet实例,在此过程中调用此方法.而HttpServlet抽象子类在Servlet接口基础之上添加了协议相关的方法.开发人员仅实现doGet和doPost方法即可. Servlet生命周期Servlet生命周期包括：加载和实例化,初始化 加载和实例化Servlet容器加载和实例化Servlet.过程如下： Servlet引擎启动 Servlet容器定位所需Servlet类 Servlet容器通过类加载器加载Servlet类（可以是本地或远程 Servlet容器实例化Servlet并使用 初始化Servlet容器对Servlet对象初始化,目的是令Servlet可以读取持久化配置数据,初始化一些代价高的资源,比如JDBC API连接.方法为init方法,已经定义在Servlet接口中. 请求处理Servlet初始化之后,容器即可使用它来处理客户端请求.客户端请求由ServletRequest类型的Request对象表示.Servlet封装响应并返回给请求的客户端.HTTP请求的场景下,容器提供的请求和响应对象具体类型分别是HttpServletRequest和HttpServletResponse. 终止服务一个Servlet实例可能会在Servlet容器内保持活跃任何时间,或长或短.当容器确定Servlet应该从服务中移除时,将调用Servlet接口的destroy方法以允许Servlet释放资源. Servlet Context在Servlet规范的章节安排中,ServletContext位于Request和Response之中.事实上,ServletContext就是用Servlet的视角描述web应用的运行状态,用户可以通过ServletContext获取其他Servlet可以访问的属性.一般情况下,每个web应用都有且只有一个ServletContext实例. 作用 可以通过ServletContext访问部署描述符(web.xml)中的上下文初始化参数. 添加,配置Servlet 添加,配置Filter 添加,配置Listener Servlet可以为ServletContext添加属性(set/get/removeAttribute(Names)) 可以通过ServletContext直接访问web应用中的静态资源(HTML,GIF等) (getResource(AsStream)) Request关于请求路径 requestURI = contextPath + servletPath + pathInfo 根据请求的URI,可以从Request获取以下路径: Context Path:对应ServletContext.如果此应用是默认应用,则为空.以/开头,不以/结尾.servlet Path:直接对应某种请求.PathInfo:可能是null,也可能是某个页面. 例如: 请求路径 路径元素 /catalog/lawn/index.html ContextPath: /catalog ServletPath: /lawn PathInfo: /index.html /catalog/garden/implements/ ContextPath: /catalog ServletPath: /garden PathInfo: /implements/ /catalog/help/feedback.jsp ContextPath: /catalog ServletPath: /help/feedback.jsp PathInfo: null ResponsesendRedirect方法设置适当的header和内容体,将客户端重定向到另一个地址,方法调用使用相对地址,但容器必须在传回客户端时转换为绝对地址. Filter用于过滤动态和静态内容的Java组件,可以改变Http请求的content,response,header等信息. 配置过滤器环境可以在web.xml中使用&lt;init-params&gt;元素初始化一组参数,运行期间可以通过Filter的FilterConfig的getInitParameter和getInitParameterNames方法得到. 可以通过@WebFilter或者在web.xml中使用&lt;filter&gt;元素定义. 详情可参阅规范中第6.2.4章节. (主要)生命周期 容器收到传入的请求 容器获取列表中第一个过滤器,并调用doFilter方法,传入ServletRequest和ServletResponse,和一个FilterChain引用. 过滤器的doFilter方法对request进行处理.一般处理方式有如下的一种或几种: 可以检查request的header. 可以将request用自定义的ServletRequest(实现)或HttpServletResponse(实现)进行包装,达到修改header或data的作用. 可以将传递给它的response用自定义的ServletResponse(实现)或HttpServletResponse(实现)包装,来修改response的header或data. 可以调用filter chain的下一个实体.下一个实体可能是另一个filter;如果此filter是chain最后一个,那下个实体就是目标Web resource. Filter与RequestDispatcher参阅规范,&lt;RequestDispatcher&gt;标签来指定在何种情况下应用Filter.可能的情况有REQUEST,FORWARD,INCLUDE,ERROR,ASYNC. Sessions由于HTTP协议是无状态的(stateless),而每个客户端的请求必须彼此有相关性.HttpSession接口由此而生.它可以让容器用几种方式来跟踪用户的会话(session). 会话(Session)跟踪机制Cookies最常用的会话跟踪机制. 容器向客户端发送cookie. 客户端在每次后续请求时都返回该cookie,表示这些请求相关联.用于跟踪会话的cookie的名字必须是JSESSIONID. URL重写会话跟踪的最低标准.当客户端不接受 cookie 时，服务器可使用 URL 重写作为会话跟踪的基础。 URL 重写涉及添加数据、会话 ID、容器解析 URL 路径从而请求与会话相关联.如 例如： http://www.myserver.com/catalog/index.html;jsessionid=1234 Dispatching Requestsweb应用部署描述符(web.xml)\定义一个文件列表,当请求的uri不可用时,尝试在其uri下寻找此列表中的文件.例如,定义 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 而实际文件静态内容为: 1234567/foo/index.html/foo/default.jsp/foo/orderform.html/foo/home.gif/catalog/default.jsp/catalog/products/shop.jsp/catalog/products/register.jsp 那么请求URI和对应结果为 请求URI 结果 /foo 重定向到 /foo/ /foo/ 返回 /foo/index.html /catalog 重定向到 /catalog/ /catalog/ 返回 /catalog/default.jsp /catalog/index.html 404 /catalog/products 重定向到 /catalog/products/ /catalog/products/ 传递给”默认”servlet,或者容器定义的其他行为]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常见命令总结]]></title>
    <url>%2F2018%2F01%2F23%2Fquick-java-command%2F</url>
    <content type="text"><![CDATA[获取参数列表 java得到基本参数列表 java -X得到扩展参数列表 运行格式 java [选项] &lt;主类&gt; [参数]用于执行类 java [选项] -jar [参数]用于执行jar文件 java [选项] -m &lt;模块&gt;[主类] [参数]用于执行模块中的主类 (其中-m可以换成–moudle) 参数全部传递到主类. java -cp 等同 -classpath 或者 –class-path 用于告知jvm搜索目录名,jar名,zip文档名,之间用;分割.格式 : java -cp &lt;目录和zip/jar文件的类搜索路径&gt; 使用此选项后,jvm不再使用CLASSPATH中的类搜索路径.如果都没有设置,则jvm使用当前路径.来作为类搜索路径.也就是常用的 java test.java. 推荐使用此参数设置的路径,而不使用CLASSPATH提供的路径,避免多个项目同时使用CLASSPATH时存在的冲突.因为jvm在搜索到第一个指定的类就会停止搜索. 例如,我开发了一个test.jar包,当我想调用其中的类时,就需要用java -cp test.jar 注意要使用完整路径. 如果没有找到则会抛出java.lang.NoClassDefFoundError异常.代码中可以用System.getProperty(&quot;java.class.path&quot;)得到jvm查找类的路径.]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的深度优先遍历项目说明文档]]></title>
    <url>%2F2018%2F01%2F22%2Fnote-graph-dfs%2F</url>
    <content type="text"><![CDATA[图的定义 从主函数开始,首先声明一个MGraph的变量: 1MGraph G; 观察MGraph: 123456typedef struct&#123; VertexType vexs[MAXVEX]; /* 顶点表 */ EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */ int numVertexes, numEdges; /* 图中当前的顶点数和边数 */ &#125;MGraph; MGraph定义了图.什么是图?请参考相关博客如 https://www.cnblogs.com/wangyingli/p/5974508.html?utm_source=tuicool&amp;utm_medium=referral 在这个程序中,用到的只是最简单的无向图.比较直观的解释: 以上图为例.每个图都有几个特征: 节点的数量 边的数量 节点与边的连接关系 怎样表示哪个点与哪条边连接呢? 首先,要对每个节点编号.比如上图,你可以编程从1到9,也可以编程从A到I.我们将这个编号保存起来,就是刚刚结构体中的属性值vexs[MAXVEX]. 其次,谁跟谁相连?我们这里用一个矩阵表示.谁跟谁相连,就把对应的坐标填充为1.如果没有相连,就填充为正无穷.如果是自己与自己相连,就填为0.如上图,连接关系为: 此连接关系表示为一个数组,就是结构体中的属性EdgeType arc[MAXVEX][MAXVEX].这个数组也被称为邻接矩阵.在表格中,每个”1”都可以看做是一个边.每个∞都可以看做是白纸. 再者由于程序要用到,这里也定义了节点和边的数量:int numVertexes, numEdges; 图的初始化 下一句代码: 1CreateMGraph(&amp;G); 这部分代码比较简单.首先赋值边的数量和节点的数量: 12G-&gt;numEdges=15;G-&gt;numVertexes=9; 然后给每个节点编号: 123456789G-&gt;vexs[0]='A';G-&gt;vexs[1]='B';G-&gt;vexs[2]='C';G-&gt;vexs[3]='D';G-&gt;vexs[4]='E';G-&gt;vexs[5]='F';G-&gt;vexs[6]='G';G-&gt;vexs[7]='H';G-&gt;vexs[8]='I'; 再然后,根据刚才所画的表,把保存着连接状态的数组初始化: 123456789101112131415161718192021222324252627282930313233//首先全部为0for (i = 0; i &lt; G-&gt;numVertexes; i++)&#123; for ( j = 0; j &lt; G-&gt;numVertexes; j++) &#123; G-&gt;arc[i][j]=0; &#125;&#125;//根据表赋值,由于表格是对称的,所以只赋值一半即可G-&gt;arc[0][1]=1;G-&gt;arc[0][5]=1;G-&gt;arc[1][2]=1; G-&gt;arc[1][8]=1; G-&gt;arc[1][6]=1; G-&gt;arc[2][3]=1; G-&gt;arc[2][8]=1; G-&gt;arc[3][4]=1;G-&gt;arc[3][7]=1;G-&gt;arc[3][6]=1;G-&gt;arc[3][8]=1;G-&gt;arc[4][5]=1;G-&gt;arc[4][7]=1;G-&gt;arc[5][6]=1; G-&gt;arc[6][7]=1; //赋值另一半for(i = 0; i &lt; G-&gt;numVertexes; i++)&#123; for(j = i; j &lt; G-&gt;numVertexes; j++) &#123; G-&gt;arc[j][i] =G-&gt;arc[i][j]; &#125;&#125; 图的深度优先遍历驱动 观察深度优先遍历方法: 1DFSTraverse(G); 什么是深度优先遍历呢?二叉树的深度优先遍历比较直观.图的深度优先遍历四路是: 使用一个数组来保存遍历每个节点的遍历状态.初始状态下,每个节点的遍历状态都是FALSE. 按照编号开始遍历,如果这个节点没有被遍历过,就使用DFS函数从它开始遍历. 这也就是DFSTraverse函数的内容. 运行 观察DFS函数: 123456789void DFS(MGraph G, int i)&#123; int j; visited[i] = TRUE; printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */ for(j = 0; j &lt; G.numVertexes; j++) if(G.arc[i][j] == 1 &amp;&amp; !visited[j]) DFS(G, j);/* 对为访问的邻接顶点递归调用 */&#125; 代码含义: 既然来到这个节点,则标记这个节点为遍历过,即令visited[i] = TRUE;. 下一步比较关键,含义为:对于这个节点,对应邻接矩阵,遍历它”邻接”的其他所有点,查看是否相连.如果相连,则继续对下一个点调用DFS.比如,对应表格,纵向来看,我们把所有竖向的字母,看成是我们关注的节点,横向的字母,看做是我们关注的节点所对应的节点们.比如,第一行,我们关注节点A,目光逐渐向右移动,发现A对应的A为0;对应的B为1,对应的C为∞,对应的D为∞,等等.我们一开始对A进行DFS方法调用,则首先标记它被遍历过,然后,目光向右移动,如果发现1.它与接下来节点的连接情况为1,2.且接下来的节点没有遍历过,那么就对接下来的节点调用DFS方法.很明显,这是一个递归操作. 输出结果 事实上,在遍历的过程中,每遍历一个节点,我们就调用printf(&quot;%c &quot;, G.vexs[i]);方法将结果输出在了控制台上. 流程图 源码 需求更新: 要求每次选择节点都时随机挑选. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include "stdio.h"#include "stdlib.h"#include "io.h"#include "math.h"#include "time.h"#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */typedef char VertexType; /* 顶点类型应由用户定义 */typedef int EdgeType; /* 边上的权值类型应由用户定义 */#define MAXSIZE 9 /* 存储空间初始分配量 */#define MAXEDGE 15#define MAXVEX 9#define INFINITY 65535typedef struct&#123; VertexType vexs[MAXVEX]; /* 顶点表 */ EdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */ int numVertexes, numEdges; /* 图中当前的顶点数和边数 */&#125;MGraph;void CreateMGraph(MGraph *G)&#123; int i, j; G-&gt;numEdges=15; G-&gt;numVertexes=9; /* 读入顶点信息，建立顶点表 */ G-&gt;vexs[0]='A'; G-&gt;vexs[1]='B'; G-&gt;vexs[2]='C'; G-&gt;vexs[3]='D'; G-&gt;vexs[4]='E'; G-&gt;vexs[5]='F'; G-&gt;vexs[6]='G'; G-&gt;vexs[7]='H'; G-&gt;vexs[8]='I'; for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */ &#123; for ( j = 0; j &lt; G-&gt;numVertexes; j++) &#123; G-&gt;arc[i][j]=0; &#125; &#125; G-&gt;arc[0][1]=1; G-&gt;arc[0][5]=1; G-&gt;arc[1][2]=1; G-&gt;arc[1][8]=1; G-&gt;arc[1][6]=1; G-&gt;arc[2][3]=1; G-&gt;arc[2][8]=1; G-&gt;arc[3][4]=1; G-&gt;arc[3][7]=1; G-&gt;arc[3][6]=1; G-&gt;arc[3][8]=1; G-&gt;arc[4][5]=1; G-&gt;arc[4][7]=1; G-&gt;arc[5][6]=1; G-&gt;arc[6][7]=1; for(i = 0; i &lt; G-&gt;numVertexes; i++) &#123; for(j = i; j &lt; G-&gt;numVertexes; j++) &#123; G-&gt;arc[j][i] =G-&gt;arc[i][j]; &#125; &#125;&#125;Boolean visited[MAXVEX]; /* 访问标志的数组 */ /* 邻接矩阵的深度优先递归算法 */ void DFS(MGraph G, int i) &#123; int j; visited[i] = TRUE; printf("%c ", G.vexs[i]);/* 打印顶点，也可以其它操作 */ srand((unsigned)time(NULL)); while (1) &#123; int j = rand() % G.numVertexes; if (G.arc[i][j] == 1 &amp;&amp; !visited[j])//相连且未曾访问 DFS(G, j);/* 对为访问的邻接顶点递归调用 */ if (isAllEdgeVisted(G, i)) &#123; break; &#125; &#125; //没有命中的情况: G.arc[i][j] != 1 || visited[j]==true //什么情况下停止? //凡是G.arc[i][j] == 1的节点都已经访问的情况下截止 &#125;Boolean isAllEdgeVisted(MGraph G,int i)&#123; int k = 0; for (; k &lt; G.numVertexes; k++)//如果此行所有连接的节点都已经访问 &#123; if (G.arc[i][k] == 1) &#123; if (!visited[k]) return FALSE; &#125; &#125; return TRUE;&#125;/* 邻接矩阵的深度遍历操作 */void DFSTraverse(MGraph G,int start)&#123; int i; for (i = 0; i &lt; G.numVertexes; i++) visited[i] = FALSE; /* 初始所有顶点状态都是未访问过状态 */ srand((unsigned)time(NULL)); DFS(G, start); while (1) &#123; int num = rand() % G.numVertexes;//产生0到G.numVertexes-1的随机数 if (!visited[num]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ DFS(G, num); if (isAllVisited(G)) break; &#125; //for (i = j; i &lt; G.numVertexes; i++) // if (!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ // DFS(G, i); //for (i = 0; i &lt; j; i++) //&#123; // if (!visited[i]) /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */ // DFS(G, i); //&#125;&#125;Boolean isAllVisited(MGraph G)&#123; int n = 0; for (; n &lt; G.numVertexes; n++) &#123; if (visited[n] == FALSE) &#123; return FALSE; &#125; &#125; return TRUE;&#125; int main(void) &#123; MGraph G; CreateMGraph(&amp;G); while (1) &#123; printf("please specify the start number:\n"); int num; scanf("%d", &amp;num); printf("result:\n"); DFSTraverse(G, num); printf("\n"); &#125; getchar(); return 0; &#125;]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>外包项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring学习笔记]]></title>
    <url>%2F2018%2F01%2F22%2Fnote-spring-study%2F</url>
    <content type="text"><![CDATA[资源spring源码发布在：http://repo.spring.io/release/org/springframework/spring/ spring文档发布在：https://spring.io/docs/reference 或 https://docs.spring.io/spring/docs/ 资源直达： springframework 3.0.0 参考 此版本在web mvc上有很大改动，延续至今。 Springframework文档重点解析Bean作用域作用域即是指实例化方式。包括singleton，prototype，request等。 Spring Web MVCsingleton， quick start 在xml文件中配置Dispatcher Servlet 在WEB-INF文件夹中创建[servlet-name]-servlet.xml格式命名的文件，其中servlet-name即是步骤1中配置的Servlet。 Dispatcher Servlet The request processing workflow of the Spring Web MVC DispatcherServlet is illustrated in thefollowing diagram. The pattern-savvy reader will recognize that the DispatcherServlet is anexpression of the “Front Controller” design pattern (this is a pattern that Spring Web MVC shares withmany other leading web frameworks). 在Spring Web MVC框架中，DispatcherServlet的地位举足轻重。在MVC设计模式中，它起到前端控制器(Front Controller)的作用,用来分发请求。 The DispatcherServlet is an actual Servlet (it inherits from the HttpServlet base class),and as such is declared in the web.xml of your web application. You need to map requests that you wantthe DispatcherServlet to handle, by using a URL mapping in the same web.xml file. This isstandard J2EE servlet configuration… 事实上，DispatcherServlet本身就是一个Servlet。在使用时，需要像其他Servlet一样配置映射url。如： 1234567891011&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;*.form&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 那么所有以.form结尾的请求将被example DispatcherServlet处理。这也是安装spring Web MVC的第一步。 ApplicationContext instances in Spring can be scoped. In the Web MVC framework, eachDispatcherServlet has its own WebApplicationContext, which inherits all the beans alreadydefined in the root WebApplicationContext. These inherited beans can be overridden in theservlet-specific scope, and you can define new scope-specific beans local to a given servlet instance. 结合图示，每个DispatcherServlet都有自己的WebApplicationContext，都继承自根WebApplicationContext，也继承了它所有的bean。根WebApplicationContext包含controller，view resolver等其他与web相关的bean。 Upon initialization of a DispatcherServlet, the framework looks for a file named[servlet-name]-servlet.xml in the WEB-INF directory of your web application and creates thebeans defined there, overriding the definitions of any beans defined with the same name in the globalscope. 接下来，配置文件[servlet-name]-servlet.xml将覆盖全局域中所有同名bean定义。如： 1234567891011&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;golfing&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;golfing&lt;/servlet-name&gt; &lt;url-pattern&gt;/golfing/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; With the above servlet configuration in place, you will need to have a file called/WEB-INF/golfing-servlet.xml in your application; this file will contain all of your Spring WebMVC-specific components (beans). You can change the exact location of this configuration file through aservlet initialization parameter (see below for details). 相应的，需要配置/WEB-INF/golfing-servlet.xml文件。这个文件包含了所有spring web mvc框架的组件（component，也是bean）。此文件的路径是可配置的。 请求处理流程： After you set up a DispatcherServlet, and a request comes in for that specificDispatcherServlet, the DispatcherServlet starts processing the request as follows: The WebApplicationContext is searched for and bound in the request as an attribute that the controller and other elements in the process can use. It is bound by default under the key DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE. The locale resolver is bound to the request to enable elements in the process to resolve the locale to use when processing the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need it. The theme resolver is bound to the request to let elements such as views determine which heme to use. If you do not use themes, you can ignore it. If you specify a multipart file resolver, the request is inspected for multiparts; if multiparts are found,the request is wrapped in a MultipartHttpServletRequest for further processing by other elements in the process. (See the section called “Using the MultipartResolver” for further information about multipart handling). An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering. If a model is returned, the view is rendered. If no model is returned, (may be due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled. 当DispatcherServlet接收到与其配置的url相匹配的请求时，作出以下处理：的 寻找WebApplicationContext，并将其绑定为controller等可用web组件的属性。默认键为DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE。 国际化相关处理。 主题相关处理。 文件相关处理。 寻找合适的handler。一旦找到，则开始准备model和rendering（对view进行渲染）。 如果返回了model，说明view已经渲染完毕。如果没有返回，则有可能是安全或其他原因，没有渲染。 @ResponseBody:参考3.0文档p429，如果一个方法注解为@ResponseBody，那么它的返回值将被写入response的HTTP body中。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring0.9学习（一） 环境准备]]></title>
    <url>%2F2018%2F01%2F22%2Fnote-spring-study-v0-9-env%2F</url>
    <content type="text"><![CDATA[资源 在spring官方博客的最后一页可以获知,spring所有的代码都储存在sourceforge上,最早的版本为0.9. 下载spring-framework-0.9.zip,查看readme. 0.9版本的的readme从readme中可以获取的,关于代码的信息: “src”包含Java源文件; “dist”包含各种Spring Jar文件; “lib”包含最重要的第三方库; “doc”包含一般和API文档; “samples”包含demo和骨架。]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统配置java开发环境]]></title>
    <url>%2F2018%2F01%2F22%2Flist-linux-java-setup%2F</url>
    <content type="text"><![CDATA[下载jdk到~/Download文件夹下,解压 管理员权限并递归复制到usr/lib/java文件夹下 123cd /usr/libmkdir java java/jdk1.8.0_161sudo cp -r /home/libinyl/Downloads/jdk1.8.0_161/ /usr/lib/java 优雅地编辑profile文件 编辑java.sh文件 1sudo gedit /etc/profile.d/java.sh 复制以下代码到编辑器中并保存 1234export JAVA_HOME=/usr/lib/java/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin 重启]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装 check list]]></title>
    <url>%2F2018%2F01%2F21%2Flist-ubuntu-setup%2F</url>
    <content type="text"><![CDATA[安装界面,如果无法看到按钮,可以用tab解决. 安装过程提示重启,不要傻等,赶紧按回车 设置软件源 软件中心-&gt;软件源-&gt;other-&gt;选择最佳 一般选阿里云 设置根用户密码: 1234 $ sudo passwd rootEnter new UNIX password:Retype new UNIX password:passwd: password updated successfully 安装vmware-tool 安装软件: 右键打开终端12sudo apt-get install nautilus-open-terminal //安装nautilus -q //重新加载文件管理器 下载工具列表: vscode vim git 安装java环境 安装包管理器gui软件 synaptic]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令速查]]></title>
    <url>%2F2018%2F01%2F21%2Fquick-hexo-command%2F</url>
    <content type="text"><![CDATA[20180617更新更换电脑或重装系统后的操作 设置github和git，添加ssh key 切记操作ssh git@github.com 下载node.js并安装 在桌面键入npm install -g hexo-cli 切换到博客文件夹，npm install 创建新博客 在博客文件夹内运行hexo new post &quot;test&quot; 即可创建test.md文件 用编辑器编辑保存 运行: hexo d -g 修改标签在每篇博客的编辑状态下,修改顶端内容如 12345---title: hexo常用命令date: 2018-01-21 20:18:18tags: [hexo,command]--- tags后面有一个空格,标签与标签间以逗号隔开. 上传图片 修改_config.yml文件post_asset_folder为true 此后,每次运行hexo new ,title时都会在_post文件夹下生成同名文件夹. 如果需要插入图片,直接插入![](图片名称)即可,无需键入文件夹名称 上传报错1234567891011121314151617Connection reset by 192.30.255.112 port 22fatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedlyFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Connection reset by 192.30.255.112 port 22fatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedly at ChildProcess.&lt;anonymous&gt; (D:\blog\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (D:\blog\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:925:16) at Socket.stream.socket.on (internal/child_process.js:346:11) at emitOne (events.js:116:13) at Socket.emit (events.js:211:7) at Pipe._handle.close [as _onclose] (net.js:554:12) 原因:连接超时,等待网络更好时尝试.]]></content>
      <categories>
        <category>技·术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>快速查阅</tag>
      </tags>
  </entry>
</search>
